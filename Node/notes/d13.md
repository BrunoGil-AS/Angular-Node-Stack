# Day 13: REST API Architecture - Routes, Controllers, and JSON

## REST API Principles

**REST** (Representational State Transfer) is an architectural style for designing networked applications. It uses standard HTTP methods to perform operations on **resources** (entities represented by URLs).

### Core REST Principles

1. **Client-Server:** Separation of concerns between client and server.
2. **Statelessness:** Each request contains all information needed; server doesn't store client context.
3. **Uniform Interface:** Consistent way to interact with resources.
4. **Resource Identification:** Resources are identified by URLs/URIs.
5. **Standard Methods:** Use HTTP methods (GET, POST, PUT, DELETE) appropriately.
6. **JSON as Data Format:** Structured, human-readable data exchange.

### REST Constraints Mapped to HTTP

```plaintext
Resource          URL               HTTP Method    Operation
────────────────────────────────────────────────────────────
Users             /api/users        GET            List all
Users             /api/users        POST           Create new
User by ID        /api/users/:id    GET            Retrieve
User by ID        /api/users/:id    PUT            Update
User by ID        /api/users/:id    DELETE         Delete
```

---

## API Endpoints and URL Design

### Naming Conventions

1. **Use nouns, not verbs** for URLs:

   ```plaintext
   ✅ GET /api/users         (List users)
   ❌ GET /api/getUsers      (Don't use verbs)

   ✅ POST /api/users        (Create user)
   ❌ POST /api/createUser   (The HTTP method implies the action)
   ```

2. **Use plural for collections**:

   ```plaintext
   /api/users          (Collection of users)
   /api/users/1        (Specific user)
   /api/users/1/posts  (User's posts - nested resource)
   ```

3. **Use hierarchies for relationships**:

   ```plaintext
   /api/users/1/posts           (All posts by user 1)
   /api/users/1/posts/5         (Post 5 by user 1)
   /api/users/1/posts/5/comments (Comments on post 5)
   ```

### Query Parameters for Filtering, Sorting, and Pagination

```typescript
// Filtering
GET /api/users?role=admin&status=active

// Sorting
GET /api/users?sort=name&order=asc

// Pagination
GET /api/users?page=1&limit=10

// Search
GET /api/users?search=john

// Combined
GET /api/users?role=admin&page=1&limit=20&sort=createdAt&order=desc
```

---

## Controller Pattern

Controllers contain the **business logic** for handling requests. They receive input from routes, process it, and send responses.

### Why Separate Controllers?

```plaintext
Route (Express Router)    →  Controller (Business Logic)  →  Model (Data)
   ↓                              ↓
Receives request          Processes request      Accesses data
Maps to handler          Returns response        Validates
```

### Example: Task Controller

```typescript
// models/Task.ts
export interface Task {
  id: number;
  title: string;
  description?: string;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// controllers/taskController.ts
import { Request, Response } from "express";

// In-memory storage (in real app, this would be a database)
let tasks: Task[] = [
  {
    id: 1,
    title: "Learn Express",
    completed: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];

let nextId = 2;

export const taskController = {
  // GET all tasks
  getAllTasks: (req: Request, res: Response): void => {
    // Pagination support
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;
    const startIndex = (page - 1) * limit;

    const paginatedTasks = tasks.slice(startIndex, startIndex + limit);

    res.json({
      data: paginatedTasks,
      pagination: {
        page,
        limit,
        total: tasks.length,
      },
    });
  },

  // GET task by ID
  getTaskById: (req: Request, res: Response): void => {
    const task = tasks.find((t) => t.id === parseInt(req.params.id));

    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }

    res.json(task);
  },

  // POST create task
  createTask: (req: Request, res: Response): void => {
    const { title, description } = req.body;

    // Validation
    if (!title || title.trim() === "") {
      res.status(400).json({ error: "Title is required" });
      return;
    }

    const newTask: Task = {
      id: nextId++,
      title,
      description,
      completed: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    tasks.push(newTask);
    res.status(201).json(newTask);
  },

  // PUT update task
  updateTask: (req: Request, res: Response): void => {
    const task = tasks.find((t) => t.id === parseInt(req.params.id));

    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }

    if (req.body.title) task.title = req.body.title;
    if (req.body.description !== undefined)
      task.description = req.body.description;
    if (req.body.completed !== undefined) task.completed = req.body.completed;
    task.updatedAt = new Date();

    res.json(task);
  },

  // PATCH partial update
  partialUpdateTask: (req: Request, res: Response): void => {
    const task = tasks.find((t) => t.id === parseInt(req.params.id));

    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }

    // Update only provided fields
    Object.assign(task, {
      ...req.body,
      updatedAt: new Date(),
      id: task.id, // Don't allow ID change
    });

    res.json(task);
  },

  // DELETE task
  deleteTask: (req: Request, res: Response): void => {
    const index = tasks.findIndex((t) => t.id === parseInt(req.params.id));

    if (index === -1) {
      res.status(404).json({ error: "Task not found" });
      return;
    }

    const deletedTask = tasks.splice(index, 1)[0];
    res.json({ message: "Task deleted", task: deletedTask });
  },
};
```

---

## Routing with Controllers

### routes/tasks.ts

```typescript
import { Router } from "express";
import { taskController } from "../controllers/taskController";

const router = Router();

// GET all tasks
router.get("/", taskController.getAllTasks);

// POST create task
router.post("/", taskController.createTask);

// GET task by ID
router.get("/:id", taskController.getTaskById);

// PUT update task
router.put("/:id", taskController.updateTask);

// PATCH partial update
router.patch("/:id", taskController.partialUpdateTask);

// DELETE task
router.delete("/:id", taskController.deleteTask);

export default router;
```

### app.ts

```typescript
import express from "express";
import tasksRouter from "./routes/tasks";

const app = express();

app.use(express.json());

// API routes
app.use("/api/tasks", tasksRouter);

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: "Route not found" });
});

export default app;
```

---

## JSON Best Practices

### Consistent Response Format

Define a standard response structure:

```typescript
// Success response
{
  "success": true,
  "data": { ... },
  "message": "Operation successful"
}

// Error response
{
  "success": false,
  "error": "Something went wrong",
  "code": "VALIDATION_ERROR"
}

// Paginated response
{
  "data": [ ... ],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "totalPages": 10
  }
}
```

### Response Helper

```typescript
// utils/response.ts
import { Response } from "express";

export const sendSuccess = (
  res: Response,
  data: any,
  statusCode: number = 200,
  message: string = "Success"
) => {
  res.status(statusCode).json({
    success: true,
    data,
    message,
  });
};

export const sendError = (
  res: Response,
  error: string,
  statusCode: number = 500,
  code: string = "ERROR"
) => {
  res.status(statusCode).json({
    success: false,
    error,
    code,
  });
};

// Usage in controllers
sendSuccess(res, task, 200, "Task created");
sendError(res, "Task not found", 404, "NOT_FOUND");
```

---

## HTTP Methods Explained

### GET - Retrieve Data

- **Safe:** Doesn't modify data
- **Idempotent:** Same request returns same result
- **Cacheable:** Can be cached

```typescript
GET /api/users        // All users
GET /api/users/1      // User 1
GET /api/users?role=admin // Filtered
```

### POST - Create Data

- **Not safe:** Creates new resources
- **Not idempotent:** Multiple requests = multiple creations
- **Request body:** Contains data to create

```typescript
POST /api/users
Content-Type: application/json

{
  "name": "John",
  "email": "john@example.com"
}
```

### PUT - Replace Full Resource

- **Not safe:** Modifies resource
- **Idempotent:** Multiple requests have same effect
- **Request body:** Complete replacement data

```typescript
PUT /api/users/1
Content-Type: application/json

{
  "name": "Jane",
  "email": "jane@example.com",
  "role": "admin"
}
```

### PATCH - Partial Update

- **Not safe:** Modifies resource
- **May or may not be idempotent** (depends on implementation)
- **Request body:** Only fields to update

```typescript
PATCH /api/users/1
Content-Type: application/json

{
  "role": "admin"
}
```

### DELETE - Remove Resource

- **Not safe:** Deletes resource
- **Idempotent:** Deleting non-existent resource returns same result
- **No body:** (usually)

```typescript
DELETE / api / users / 1;
```

---

## Error Handling in APIs

```typescript
// Centralized error handling middleware
app.use((err: any, req: Request, res: Response, next) => {
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || "Internal Server Error";

  res.status(statusCode).json({
    success: false,
    error: message,
    code: err.code || "ERROR",
  });
});
```

---

## Summary

- **REST APIs** use resources (URLs) and HTTP methods to create clean, predictable interfaces.
- **Controllers** separate business logic from routing.
- **JSON** is the standard format for API communication.
- **Consistent response formats** make APIs easier to consume.
- **Proper HTTP methods** (GET, POST, PUT, PATCH, DELETE) communicate intent clearly.
- **Statelessness** means each request must be complete and independent.
