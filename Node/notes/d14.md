# Day 14: Middleware and Error Handling

## What is Middleware?

**Middleware** functions are functions that have access to the **request object (req)**, **response object (res)**, and the **next middleware function** in the application's request-response cycle.

### Middleware Flow

```plaintext
Request
   ↓
Middleware 1
   ↓
Middleware 2
   ↓
Middleware 3
   ↓
Route Handler
   ↓
Middleware (response processing)
   ↓
Response
```

### Basic Middleware Signature

```typescript
// Middleware function
const myMiddleware = (req: Request, res: Response, next: NextFunction) => {
  console.log("Middleware executed");
  next(); // Pass control to next middleware/route
};

// Apply to all routes
app.use(myMiddleware);

// Apply to specific route
app.get("/route", myMiddleware, (req: Request, res: Response) => {
  res.send("Route handler");
});
```

---

## Common Built-in Middleware

### 1. JSON Body Parser

```typescript
// Parse incoming JSON request bodies
app.use(express.json());

// Parse form data
app.use(express.urlencoded({ extended: true }));

// Limit file upload size
app.use(express.json({ limit: "10mb" }));
```

### 2. Static Files

```typescript
// Serve static files from public directory
app.use(express.static("public"));

// Access as: http://localhost:3000/style.css (from public/style.css)
```

### 3. CORS (Cross-Origin Resource Sharing)

`CORS` stands for **_Cross-Origin Resource Sharing_**. It’s a protocol that lets servers specify which domains, schemes, or ports can access their resources. By default, browsers block requests from one origin (domain, protocol, or port) to another for security reasons. CORS provides a safe way to enable exceptions.

```typescript
import cors from "cors";

// Allow all origins
app.use(cors());

// Allow specific origins
app.use(
  cors({
    origin: "http://localhost:4200",
    credentials: true,
  })
);

// Allow specific methods and headers
app.use(
  cors({
    origin: ["http://localhost:4200", "http://localhost:3000"],
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);
```

---

## Custom Middleware

### 1. Logging Middleware

```typescript
const loggingMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();
  const timestamp = new Date().toISOString();

  console.log(`[${timestamp}] ${req.method} ${req.url}`);

  // Capture when response is sent
  res.on("finish", () => {
    const duration = Date.now() - startTime;
    console.log(
      `✓ ${req.method} ${req.url} - ${res.statusCode} (${duration}ms)`
    );
  });

  next();
};

app.use(loggingMiddleware);
```

### 2. Authentication Middleware

```typescript
interface AuthenticatedRequest extends Request {
  user?: { id: string; role: string };
}

const authMiddleware = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.headers.authorization?.split(" ")[1]; // Bearer token

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    // In real app, verify JWT
    const decoded = { id: "123", role: "user" }; // Simplified
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: "Invalid token" });
  }
};

app.get(
  "/protected",
  authMiddleware,
  (req: AuthenticatedRequest, res: Response) => {
    res.json({ message: `Hello ${req.user?.id}` });
  }
);
```

### 3. Authorization Middleware

```typescript
const requireRole = (allowedRoles: string[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: "User not authenticated" });
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: "Access denied" });
    }

    next();
  };
};

// Usage
app.delete(
  "/api/users/:id",
  authMiddleware,
  requireRole(["admin"]),
  (req, res) => {
    res.json({ message: "User deleted" });
  }
);
```

### 4. Request Validation Middleware

```typescript
const validateTaskInput = (req: Request, res: Response, next: NextFunction) => {
  const { title, description } = req.body;

  // Validation rules
  const errors: string[] = [];

  if (!title || title.trim() === "") {
    errors.push("Title is required");
  }

  if (title && title.length > 100) {
    errors.push("Title must be less than 100 characters");
  }

  if (description && description.length > 500) {
    errors.push("Description must be less than 500 characters");
  }

  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }

  next();
};

app.post("/api/tasks", validateTaskInput, (req: Request, res: Response) => {
  // Safe to process: input is valid
  res.json({ message: "Task created" });
});
```

### 5. Rate Limiting Middleware

```typescript
import rateLimit from "express-rate-limit";

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: "Too many requests, please try again later",
});

// Apply to all requests
app.use(limiter);

// Or to specific routes
app.post("/api/login", limiter, (req: Request, res: Response) => {
  // Login logic
});
```

### 6. Request Enhancement Middleware

```typescript
const enrichRequest = (req: Request, res: Response, next: NextFunction) => {
  // Add useful data to request
  (req as any).requestId = Math.random().toString(36).substr(2, 9);
  (req as any).startTime = Date.now();
  (req as any).user = null; // Will be populated by auth middleware

  next();
};

app.use(enrichRequest);
```

---

## Error Handling

### Types of Errors

1. **Validation Errors:** Invalid input from client
2. **Authentication Errors:** User not logged in
3. **Authorization Errors:** User doesn't have permission
4. **Not Found Errors:** Resource doesn't exist
5. **Server Errors:** Unexpected errors in application

### Error Handler Middleware

Error handler middleware must have **4 parameters** (including `err`):

```typescript
// ❌ This is a regular middleware
app.use((req, res, next) => {
  res.send("Hello");
});

// ✅ This is an error handler middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err);
  res.status(500).json({ error: "Internal Server Error" });
});
```

### Custom Error Class

```typescript
class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public code: string = "ERROR"
  ) {
    super(message);
    this.name = "ApiError";
  }
}

// Usage
throw new ApiError(404, "User not found", "USER_NOT_FOUND");
```

### Centralized Error Handler

```typescript
// errorHandler.ts
import { Request, Response, NextFunction } from "express";

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public code: string = "ERROR"
  ) {
    super(message);
    this.name = "ApiError";
  }
}

export const errorHandler = (
  err: Error | ApiError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error("Error:", err.message);

  if (err instanceof ApiError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message,
      code: err.code,
    });
  }

  // Unexpected error
  res.status(500).json({
    success: false,
    error: "Internal Server Error",
    code: "INTERNAL_ERROR",
  });
};

// app.ts
import { errorHandler } from "./middleware/errorHandler";

app.use(express.json());
app.use(routes);
app.use(errorHandler); // Must be last!
```

### Using Custom Errors in Controllers

```typescript
import { ApiError } from "../middleware/errorHandler";

export const taskController = {
  getTaskById: (req: Request, res: Response, next: NextFunction) => {
    const task = tasks.find((t) => t.id === parseInt(req.params.id));

    if (!task) {
      // Pass error to error handler
      throw new ApiError(404, "Task not found", "TASK_NOT_FOUND");
    }

    res.json(task);
  },
};
```

### Async Error Wrapper

For async route handlers, errors won't be caught automatically:

```typescript
// utils/asyncHandler.ts
import { Request, Response, NextFunction } from "express";

export const asyncHandler = (
  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>
) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Usage
app.get(
  "/tasks/:id",
  asyncHandler(async (req: Request, res: Response) => {
    const task = await getTaskFromDatabase(req.params.id);
    if (!task) {
      throw new ApiError(404, "Task not found");
    }
    res.json(task);
  })
);
```

---

## Middleware Order Matters

```typescript
const app = express();

// 1. Body parsers must come first
app.use(express.json());

// 2. CORS and static files
app.use(cors());
app.use(express.static("public"));

// 3. Custom middleware
app.use(loggingMiddleware);
app.use(enrichRequest);

// 4. Authentication
app.use(authMiddleware);

// 5. Routes
app.use("/api/tasks", tasksRouter);

// 6. 404 handler
app.use((req, res) => {
  res.status(404).json({ error: "Route not found" });
});

// 7. Error handler (MUST BE LAST)
app.use(errorHandler);
```

---

## Complete Example: Middleware + Error Handling

```typescript
import express, { Express, Request, Response, NextFunction } from "express";
import cors from "cors";

class ApiError extends Error {
  constructor(public statusCode: number, public message: string) {
    super(message);
  }
}

const app: Express = express();

// Middleware
app.use(express.json());
app.use(cors());

// Logging
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

// Routes
app.get("/api/data", (req, res) => {
  res.json({ data: "Hello World" });
});

app.get("/api/error", (req, res, next) => {
  next(new ApiError(400, "Something went wrong"));
});

// 404
app.use((req, res) => {
  res.status(404).json({ error: "Not found" });
});

// Error handler
app.use(
  (err: Error | ApiError, req: Request, res: Response, next: NextFunction) => {
    if (err instanceof ApiError) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    res.status(500).json({ error: "Internal Server Error" });
  }
);

app.listen(3000, () => console.log("Server running"));
```

---

## Summary

- **Middleware** functions process requests before they reach route handlers.
- **Order matters:** Body parsers → Custom middleware → Routes → Error handler.
- **Custom middleware** enables logging, authentication, validation, and more.
- **Error handler middleware** must have 4 parameters and come last.
- **Custom error classes** provide structured error responses.
- **Async handlers** need a wrapper to catch Promise rejections.
