# Day 27: Full CRUD with DB

## üéØ Objective

Connect your API routes to a database and implement complete CRUD operations with proper separation of concerns.

---

## üìö Table of Contents

1. [Async/Await Fundamentals](#1-asyncawait-fundamentals)
2. [Mongoose Setup and Methods](#2-mongoose-setup-and-methods)
3. [Service Layer Pattern](#3-service-layer-pattern)
4. [Complete CRUD Implementation](#4-complete-crud-implementation)

---

## 1. Async/Await Fundamentals

### Why Async/Await?

Database operations take time (network latency, disk I/O), so they're **asynchronous**. JavaScript provides async/await to handle these operations cleanly without blocking code execution.

### Before Async/Await (Callback Hell)

```typescript
// ‚ùå Old way - Callback hell
db.findUser(id, (err, user) => {
  if (err) {
    handleError(err);
  } else {
    db.findPosts(user.id, (err, posts) => {
      if (err) {
        handleError(err);
      } else {
        // More nesting...
      }
    });
  }
});
```

### With Async/Await

```typescript
// ‚úÖ Modern way - Clean and readable
async function getUserWithPosts(id: string) {
  try {
    const user = await db.findUser(id);
    const posts = await db.findPosts(user.id);
    return { user, posts };
  } catch (error) {
    handleError(error);
  }
}
```

### Key Concepts

```typescript
// src/examples/async-basics.ts

// Example 1: Basic async function
async function fetchData(): Promise<string> {
  // Simulate database delay
  return new Promise((resolve) => {
    setTimeout(() => resolve("Data fetched!"), 1000);
  });
}

// Example 2: Using await
async function processData() {
  console.log("Starting...");

  const data = await fetchData(); // Waits for promise to resolve
  console.log(data); // 'Data fetched!' (after 1 second)

  console.log("Done!");
}

// Example 3: Error handling
async function fetchWithErrorHandling() {
  try {
    const result = await fetchData();
    return result;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

// Example 4: Multiple async operations
async function parallelOperations() {
  // Sequential (slower)
  const user1 = await fetchUser(1);
  const user2 = await fetchUser(2);

  // Parallel (faster)
  const [user3, user4] = await Promise.all([fetchUser(3), fetchUser(4)]);
}
```

**Important Rules:**

- `async` functions always return a Promise
- `await` can only be used inside `async` functions
- Always use try/catch for error handling

---

## 2. Mongoose Setup and Methods

### Installing Dependencies

```bash
npm install mongoose
npm install -D @types/mongoose
```

### Database Connection

```typescript
// src/config/database.ts
import mongoose from "mongoose";

export class Database {
  static async connect(): Promise<void> {
    try {
      const mongoUri =
        process.env.MONGO_URI || "mongodb://localhost:27017/angular-node-stack";

      await mongoose.connect(mongoUri);

      console.log("‚úÖ MongoDB connected successfully");
    } catch (error) {
      console.error("‚ùå MongoDB connection error:", error);
      process.exit(1); // Exit if cannot connect
    }
  }

  static async disconnect(): Promise<void> {
    try {
      await mongoose.disconnect();
      console.log("MongoDB disconnected");
    } catch (error) {
      console.error("Error disconnecting from MongoDB:", error);
    }
  }
}

// Handle connection events
mongoose.connection.on("connected", () => {
  console.log("Mongoose connected to MongoDB");
});

mongoose.connection.on("error", (err) => {
  console.error("Mongoose connection error:", err);
});

mongoose.connection.on("disconnected", () => {
  console.log("Mongoose disconnected from MongoDB");
});
```

### Update .env File

```env
MONGO_URI=mongodb://localhost:27017/angular-node-stack
# For MongoDB Atlas (cloud):
# MONGO_URI=mongodb+srv://username:password@cluster.mongodb.net/dbname
```

### Mongoose Schema and Model

```typescript
// src/models/product.model.ts
import mongoose, { Document, Schema } from "mongoose";

// TypeScript Interface for type safety
export interface IProduct {
  name: string;
  description: string;
  price: number;
  category: string;
  inStock: boolean;
  createdAt?: Date;
  updatedAt?: Date;
}

// Interface that extends Document (Mongoose type)
export interface IProductDocument extends IProduct, Document {
  _id: mongoose.Types.ObjectId;
}

// Mongoose Schema
const productSchema = new Schema<IProductDocument>(
  {
    name: {
      type: String,
      required: [true, "Product name is required"],
      trim: true,
      minlength: [3, "Name must be at least 3 characters"],
      maxlength: [100, "Name cannot exceed 100 characters"],
    },
    description: {
      type: String,
      required: [true, "Description is required"],
      minlength: [10, "Description must be at least 10 characters"],
    },
    price: {
      type: Number,
      required: [true, "Price is required"],
      min: [0, "Price cannot be negative"],
    },
    category: {
      type: String,
      required: [true, "Category is required"],
      enum: {
        values: ["Electronics", "Clothing", "Food", "Books", "Other"],
        message: "{VALUE} is not a valid category",
      },
    },
    inStock: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true, // Automatically adds createdAt and updatedAt
  },
);

// Create and export the model
export const ProductModel = mongoose.model<IProductDocument>(
  "Product",
  productSchema,
);
```

### Essential Mongoose Methods

```typescript
// src/examples/mongoose-methods.ts
import { ProductModel, IProductDocument } from "../models/product.model";

export class MongooseMethodsExample {
  // 1. CREATE - .create()
  static async createExample() {
    const newProduct = await ProductModel.create({
      name: "Laptop",
      description: "High-performance laptop",
      price: 999.99,
      category: "Electronics",
      inStock: true,
    });

    console.log("Created:", newProduct);
    return newProduct;
  }

  // 2. READ - .find(), .findById(), .findOne()
  static async readExamples() {
    // Find all products
    const allProducts = await ProductModel.find();

    // Find with filter
    const electronics = await ProductModel.find({ category: "Electronics" });

    // Find one product
    const oneProduct = await ProductModel.findOne({ name: "Laptop" });

    // Find by ID
    const productById = await ProductModel.findById("507f1f77bcf86cd799439011");

    // Find with select (specific fields)
    const names = await ProductModel.find().select("name price");

    // Find with sort and limit
    const topExpensive = await ProductModel.find()
      .sort({ price: -1 }) // -1 for descending
      .limit(5);

    return { allProducts, electronics, oneProduct };
  }

  // 3. UPDATE - .findByIdAndUpdate(), .updateOne()
  static async updateExamples() {
    // Update by ID (returns updated document)
    const updated = await ProductModel.findByIdAndUpdate(
      "507f1f77bcf86cd799439011",
      { price: 899.99, inStock: false },
      { new: true, runValidators: true }, // Options
    );

    // Update one document
    await ProductModel.updateOne(
      { name: "Laptop" },
      { $set: { price: 799.99 } },
    );

    // Update many documents
    await ProductModel.updateMany(
      { category: "Electronics" },
      { $set: { inStock: true } },
    );

    return updated;
  }

  // 4. DELETE - .findByIdAndDelete(), .deleteOne()
  static async deleteExamples() {
    // Delete by ID (returns deleted document)
    const deleted = await ProductModel.findByIdAndDelete(
      "507f1f77bcf86cd799439011",
    );

    // Delete one document
    await ProductModel.deleteOne({ name: "Laptop" });

    // Delete many documents
    await ProductModel.deleteMany({ inStock: false });

    return deleted;
  }

  // 5. ADVANCED - Chaining queries
  static async advancedQueries() {
    // Complex query with multiple conditions
    const results = await ProductModel.find({
      price: { $gte: 100, $lte: 1000 }, // Between 100 and 1000
      category: "Electronics",
      inStock: true,
    })
      .select("name price category")
      .sort({ price: 1 })
      .limit(10)
      .skip(0); // For pagination

    // Count documents
    const count = await ProductModel.countDocuments({
      category: "Electronics",
    });

    return { results, count };
  }
}
```

**Key Options:**

- `{ new: true }`: Return the updated document instead of the original
- `{ runValidators: true }`: Run schema validators on update
- `{ upsert: true }`: Create document if it doesn't exist

---

## 3. Service Layer Pattern

### Why Separate Services from Controllers?

**Controller** (HTTP Layer):

- Handles HTTP requests/responses
- Validates input
- Calls service methods
- Returns appropriate status codes

**Service** (Business Logic Layer):

- Contains business logic
- Interacts with database
- Reusable across different controllers
- Easier to test

### Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ HTTP Request
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Controller ‚îÇ ‚Üê Handles HTTP, validates input
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Calls methods
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Service   ‚îÇ ‚Üê Business logic, DB operations
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Uses
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Model    ‚îÇ ‚Üê Database schema
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4. Complete CRUD Implementation

### DTOs (Data Transfer Objects)

```typescript
// src/dtos/product.dto.ts

export interface CreateProductDto {
  name: string;
  description: string;
  price: number;
  category: string;
  inStock?: boolean;
}

export interface UpdateProductDto {
  name?: string;
  description?: string;
  price?: number;
  category?: string;
  inStock?: boolean;
}

export interface ProductResponseDto {
  id: string;
  name: string;
  description: string;
  price: number;
  category: string;
  inStock: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

### Service Layer

```typescript
// src/services/product.service.ts
import { ProductModel, IProductDocument } from "../models/product.model";
import {
  CreateProductDto,
  UpdateProductDto,
  ProductResponseDto,
} from "../dtos/product.dto";

export class ProductService {
  /**
   * Get all products with optional filtering
   */
  static async getAllProducts(filters?: {
    category?: string;
    inStock?: boolean;
    minPrice?: number;
    maxPrice?: number;
  }): Promise<ProductResponseDto[]> {
    try {
      const query: any = {};

      // Build query based on filters
      if (filters?.category) {
        query.category = filters.category;
      }
      if (filters?.inStock !== undefined) {
        query.inStock = filters.inStock;
      }
      if (filters?.minPrice !== undefined || filters?.maxPrice !== undefined) {
        query.price = {};
        if (filters.minPrice !== undefined) {
          query.price.$gte = filters.minPrice;
        }
        if (filters.maxPrice !== undefined) {
          query.price.$lte = filters.maxPrice;
        }
      }

      const products = await ProductModel.find(query).sort({ createdAt: -1 }); // Newest first

      return products.map(this.mapToDto);
    } catch (error) {
      throw new Error(
        `Error fetching products: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Get a single product by ID
   */
  static async getProductById(id: string): Promise<ProductResponseDto> {
    try {
      const product = await ProductModel.findById(id);

      if (!product) {
        throw new Error("Product not found");
      }

      return this.mapToDto(product);
    } catch (error) {
      if (error instanceof Error && error.message === "Product not found") {
        throw error;
      }
      throw new Error(
        `Error fetching product: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Create a new product
   */
  static async createProduct(
    dto: CreateProductDto,
  ): Promise<ProductResponseDto> {
    try {
      const product = await ProductModel.create(dto);
      return this.mapToDto(product);
    } catch (error: any) {
      // Handle validation errors
      if (error.name === "ValidationError") {
        const messages = Object.values(error.errors).map(
          (err: any) => err.message,
        );
        throw new Error(`Validation error: ${messages.join(", ")}`);
      }
      throw new Error(`Error creating product: ${error.message}`);
    }
  }

  /**
   * Update a product by ID
   */
  static async updateProduct(
    id: string,
    dto: UpdateProductDto,
  ): Promise<ProductResponseDto> {
    try {
      const product = await ProductModel.findByIdAndUpdate(
        id,
        { $set: dto },
        { new: true, runValidators: true },
      );

      if (!product) {
        throw new Error("Product not found");
      }

      return this.mapToDto(product);
    } catch (error: any) {
      if (error.message === "Product not found") {
        throw error;
      }
      if (error.name === "ValidationError") {
        const messages = Object.values(error.errors).map(
          (err: any) => err.message,
        );
        throw new Error(`Validation error: ${messages.join(", ")}`);
      }
      throw new Error(`Error updating product: ${error.message}`);
    }
  }

  /**
   * Delete a product by ID
   */
  static async deleteProduct(id: string): Promise<void> {
    try {
      const product = await ProductModel.findByIdAndDelete(id);

      if (!product) {
        throw new Error("Product not found");
      }
    } catch (error) {
      if (error instanceof Error && error.message === "Product not found") {
        throw error;
      }
      throw new Error(
        `Error deleting product: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Get products by category
   */
  static async getProductsByCategory(
    category: string,
  ): Promise<ProductResponseDto[]> {
    try {
      const products = await ProductModel.find({ category }).sort({ name: 1 });

      return products.map(this.mapToDto);
    } catch (error) {
      throw new Error(
        `Error fetching products by category: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Search products by name
   */
  static async searchProducts(
    searchTerm: string,
  ): Promise<ProductResponseDto[]> {
    try {
      const products = await ProductModel.find({
        name: { $regex: searchTerm, $options: "i" }, // Case-insensitive search
      });

      return products.map(this.mapToDto);
    } catch (error) {
      throw new Error(
        `Error searching products: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Helper: Map Mongoose document to DTO
   */
  private static mapToDto(product: IProductDocument): ProductResponseDto {
    return {
      id: product._id.toString(),
      name: product.name,
      description: product.description,
      price: product.price,
      category: product.category,
      inStock: product.inStock,
      createdAt: product.createdAt!,
      updatedAt: product.updatedAt!,
    };
  }
}
```

### Controller Layer

```typescript
// src/controllers/product.controller.ts
import { Request, Response } from "express";
import { ProductService } from "../services/product.service";
import { CreateProductDto, UpdateProductDto } from "../dtos/product.dto";

export class ProductController {
  /**
   * GET /api/products
   * Get all products with optional filters
   */
  static async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { category, inStock, minPrice, maxPrice } = req.query;

      const filters = {
        category: category as string | undefined,
        inStock:
          inStock === "true" ? true : inStock === "false" ? false : undefined,
        minPrice: minPrice ? parseFloat(minPrice as string) : undefined,
        maxPrice: maxPrice ? parseFloat(maxPrice as string) : undefined,
      };

      const products = await ProductService.getAllProducts(filters);

      res.status(200).json({
        success: true,
        count: products.length,
        data: products,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error fetching products",
      });
    }
  }

  /**
   * GET /api/products/:id
   * Get a single product by ID
   */
  static async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      const product = await ProductService.getProductById(id);

      res.status(200).json({
        success: true,
        data: product,
      });
    } catch (error) {
      const statusCode =
        error instanceof Error && error.message === "Product not found"
          ? 404
          : 500;

      res.status(statusCode).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error fetching product",
      });
    }
  }

  /**
   * POST /api/products
   * Create a new product
   */
  static async create(req: Request, res: Response): Promise<void> {
    try {
      const dto: CreateProductDto = req.body;

      // Basic validation
      if (
        !dto.name ||
        !dto.description ||
        dto.price === undefined ||
        !dto.category
      ) {
        res.status(400).json({
          success: false,
          message:
            "Missing required fields: name, description, price, category",
        });
        return;
      }

      const product = await ProductService.createProduct(dto);

      res.status(201).json({
        success: true,
        message: "Product created successfully",
        data: product,
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error creating product",
      });
    }
  }

  /**
   * PUT /api/products/:id
   * Update a product by ID
   */
  static async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const dto: UpdateProductDto = req.body;

      // Validate at least one field is provided
      if (Object.keys(dto).length === 0) {
        res.status(400).json({
          success: false,
          message: "No fields to update",
        });
        return;
      }

      const product = await ProductService.updateProduct(id, dto);

      res.status(200).json({
        success: true,
        message: "Product updated successfully",
        data: product,
      });
    } catch (error) {
      const statusCode =
        error instanceof Error && error.message === "Product not found"
          ? 404
          : 400;

      res.status(statusCode).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error updating product",
      });
    }
  }

  /**
   * DELETE /api/products/:id
   * Delete a product by ID
   */
  static async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      await ProductService.deleteProduct(id);

      res.status(200).json({
        success: true,
        message: "Product deleted successfully",
      });
    } catch (error) {
      const statusCode =
        error instanceof Error && error.message === "Product not found"
          ? 404
          : 500;

      res.status(statusCode).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error deleting product",
      });
    }
  }

  /**
   * GET /api/products/category/:category
   * Get products by category
   */
  static async getByCategory(req: Request, res: Response): Promise<void> {
    try {
      const { category } = req.params;

      const products = await ProductService.getProductsByCategory(category);

      res.status(200).json({
        success: true,
        count: products.length,
        data: products,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error fetching products",
      });
    }
  }

  /**
   * GET /api/products/search?q=searchTerm
   * Search products by name
   */
  static async search(req: Request, res: Response): Promise<void> {
    try {
      const { q } = req.query;

      if (!q || typeof q !== "string") {
        res.status(400).json({
          success: false,
          message: "Search term is required",
        });
        return;
      }

      const products = await ProductService.searchProducts(q);

      res.status(200).json({
        success: true,
        count: products.length,
        data: products,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message:
          error instanceof Error ? error.message : "Error searching products",
      });
    }
  }
}
```

### Routes

```typescript
// src/routes/product.routes.ts
import { Router } from "express";
import { ProductController } from "../controllers/product.controller";

const router = Router();

// Search route (must be before :id route)
router.get("/search", ProductController.search);

// Category route
router.get("/category/:category", ProductController.getByCategory);

// CRUD routes
router.get("/", ProductController.getAll);
router.get("/:id", ProductController.getById);
router.post("/", ProductController.create);
router.put("/:id", ProductController.update);
router.delete("/:id", ProductController.delete);

export default router;
```

### Main Application Setup

```typescript
// src/app.ts
import express from "express";
import dotenv from "dotenv";
import { Database } from "./config/database";
import productRoutes from "./routes/product.routes";

dotenv.config();

const app = express();

// Middleware
app.use(express.json());

// Routes
app.use("/api/products", productRoutes);

// Health check
app.get("/health", (req, res) => {
  res.json({
    success: true,
    message: "Server is running",
    timestamp: new Date().toISOString(),
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: "Route not found",
  });
});

export default app;
```

```typescript
// src/server.ts
import app from "./app";
import { Database } from "./config/database";

const PORT = process.env.PORT || 3000;

async function startServer() {
  try {
    // Connect to database
    await Database.connect();

    // Start server
    app.listen(PORT, () => {
      console.log(`üöÄ Server running on http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on("SIGINT", async () => {
  console.log("\nüõë Shutting down gracefully...");
  await Database.disconnect();
  process.exit(0);
});

startServer();
```

---

## üß™ Testing with Thunder Client / Postman

### 1. Create a Product

```http
POST http://localhost:3000/api/products
Content-Type: application/json

{
  "name": "MacBook Pro",
  "description": "High-performance laptop for developers",
  "price": 2499.99,
  "category": "Electronics",
  "inStock": true
}
```

### 2. Get All Products

```http
GET http://localhost:3000/api/products
```

### 3. Get All Products with Filters

```http
GET http://localhost:3000/api/products?category=Electronics&inStock=true&minPrice=1000
```

### 4. Get Product by ID

```http
GET http://localhost:3000/api/products/65abc123def456789
```

### 5. Update Product

```http
PUT http://localhost:3000/api/products/65abc123def456789
Content-Type: application/json

{
  "price": 2299.99,
  "inStock": false
}
```

### 6. Delete Product

```http
DELETE http://localhost:3000/api/products/65abc123def456789
```

### 7. Search Products

```http
GET http://localhost:3000/api/products/search?q=MacBook
```

### 8. Get Products by Category

```http
GET http://localhost:3000/api/products/category/Electronics
```

---

## üì¶ Complete Project Structure

```
src/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ database.ts          # Database connection
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ product.controller.ts # HTTP handlers
‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îî‚îÄ‚îÄ product.dto.ts       # Data Transfer Objects
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ product.model.ts     # Mongoose schema
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ product.routes.ts    # API routes
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ product.service.ts   # Business logic
‚îú‚îÄ‚îÄ app.ts                   # Express app setup
‚îî‚îÄ‚îÄ server.ts                # Server entry point
```

---

## üéì Key Learnings

### Async/Await

- ‚úÖ Use `async/await` for all database operations
- ‚úÖ Always wrap in `try/catch` for error handling
- ‚úÖ Understand the difference between sequential and parallel execution

### Mongoose Methods

- ‚úÖ **Create**: `Model.create()`, `new Model().save()`
- ‚úÖ **Read**: `.find()`, `.findById()`, `.findOne()`
- ‚úÖ **Update**: `.findByIdAndUpdate()`, `.updateOne()`
- ‚úÖ **Delete**: `.findByIdAndDelete()`, `.deleteOne()`

### Service Layer Pattern

- ‚úÖ **Controllers**: Handle HTTP, validate input, call services
- ‚úÖ **Services**: Contain business logic, interact with database
- ‚úÖ **Models**: Define data structure and validation
- ‚úÖ **DTOs**: Type-safe data transfer between layers

---

## üöÄ Next Steps

1. **Add Pagination**: Implement limit and skip for large datasets
2. **Add Validation**: Use libraries like `class-validator` or `joi`
3. **Error Handling**: Create custom error classes and global error handler
4. **Testing**: Write unit tests for services and integration tests for routes
5. **Relationships**: Learn Mongoose population for related documents
6. **Indexes**: Add database indexes for better query performance

---

## üí° Best Practices

1. **Always use async/await** for database operations
2. **Separate concerns**: Controller ‚Üí Service ‚Üí Model
3. **Use DTOs** for type safety and validation
4. **Handle errors gracefully** with try/catch
5. **Return consistent responses** with success/error format
6. **Validate input** before passing to service layer
7. **Use TypeScript interfaces** for type safety
8. **Keep services reusable** and testable

You now have a complete CRUD API with proper separation of concerns! üéâ
