# Day 11: Node.js Fundamentals - The Runtime & Event Loop

## Understanding Node.js

Node.js is a **JavaScript runtime environment** that allows you to execute JavaScript outside the browser. It was built on top of Chrome's V8 engine and designed specifically for building scalable network applications on the server side.

### Why Node.js?

- **JavaScript Everywhere:** Use the same language for frontend and backend.
- **Non-blocking I/O:** Efficiently handle thousands of concurrent connections.
- **Event-Driven:** Perfect for real-time applications (chat, notifications, dashboards).
- **NPM Ecosystem:** Massive package repository for rapid development.

---

## The Node.js Runtime

### What is a Runtime?

A runtime is an **execution environment** that provides the necessary infrastructure to run code. It includes:

1. **V8 Engine:** Converts JavaScript to machine code.
2. **libuv Library:** Handles async I/O operations (the heart of Node's non-blocking nature).
3. **Standard Library:** Built-in modules like `fs`, `http`, `path`, etc.

```plain
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Your JavaScript Code        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Node.js Runtime              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   V8 Engine               â”‚  â”‚
â”‚  â”‚ (JS â†’ Machine Code)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   libuv Library           â”‚  â”‚
â”‚  â”‚ (Async I/O, Event Loop)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Standard Library        â”‚  â”‚
â”‚  â”‚ (fs, http, path, etc.)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Operating System              â”‚
â”‚ (File System, Network, Threads) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## The Event Loop: Heart of Node.js

The **Event Loop** is what makes Node.js non-blocking. It's a mechanism that executes JavaScript callbacks and handles I/O operations efficiently.

### The Problem: Blocking Operations

In traditional **blocking I/O**, reading a file looks like this:

```javascript
// âŒ BLOCKING - application is frozen while waiting
const data = fs.readFileSync("large-file.txt"); // Waits here...
console.log(data); // Only executed after file is fully read
doOtherWork(); // Stuck waiting!
```

### The Solution: Non-Blocking I/O with Callbacks

```javascript
// âœ… NON-BLOCKING - application continues while waiting
fs.readFile("large-file.txt", (err, data) => {
  if (err) throw err;
  console.log(data); // Executed when file is ready
});
console.log("File reading started, continuing with other work...");
doOtherWork(); // Runs immediately!
```

### How the Event Loop Works (Simplified)

```plain
1. JavaScript Code Execution
   â†“
2. Check for Completed Async Operations (timers, I/O)
   â†“
3. Execute Callbacks for Completed Operations
   â†“
4. Check for More Work
   â”œâ”€ If yes â†’ Go to step 1
   â””â”€ If no â†’ Exit
```

### Event Loop Phases (Detailed)

Node's event loop has several phases that execute in order:

```plain
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Event Loop Execution Order              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. timers                                       â”‚
â”‚    (setTimeout, setInterval callbacks)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. pending callbacks                            â”‚
â”‚    (I/O errors, some system operations)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. idle, prepare                                â”‚
â”‚    (Internal use)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. poll                                         â”‚
â”‚    (I/O events - files, network, etc.)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5. check                                        â”‚
â”‚    (setImmediate callbacks)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6. close callbacks                              â”‚
â”‚    (Socket closeups, connection terminations)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Example: Understanding Event Loop Order

```typescript
console.log("1. Synchronous start");

setTimeout(() => {
  console.log("2. setTimeout (timers phase)");
}, 0);

setImmediate(() => {
  console.log("3. setImmediate (check phase)");
});

Promise.resolve().then(() => {
  console.log("4. Promise (Microtask Queue)");
});

console.log("5. Synchronous end");

// Output:
// 1. Synchronous start
// 5. Synchronous end
// 4. Promise (Microtask Queue)
// 2. setTimeout (timers phase)
// 3. setImmediate (check phase)
```

### Key Concept: Microtask Queue vs. Macrotask Queue

The event loop also manages two special queues:

```plain
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Callback Execution                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Execute all Synchronous Code                     â”‚
â”‚ 2. Execute all Microtasks (Promises, process.nextTick)
â”‚ 3. Execute ONE Macrotask (setTimeout, setInterval)  â”‚
â”‚ 4. Execute all Microtasks again                     â”‚
â”‚ 5. Repeat from step 3                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Microtasks** (High Priority):

- Promise callbacks (`.then()`, `.catch()`)
- `process.nextTick()`
- `queueMicrotask()`

**Macrotasks** (Lower Priority):

- `setTimeout()`
- `setInterval()`
- I/O operations
- `setImmediate()`

---

## Node.js Modules

Node.js uses a **module system** to organize code. Each file is a module that can export and import functionality.

### CommonJS vs. ES Modules

#### CommonJS (Traditional)

```typescript
// math.js
function add(a: number, b: number): number {
  return a + b;
}

module.exports = { add };

// app.js
const { add } = require("./math");
console.log(add(2, 3)); // 5
```

#### ES Modules (Modern, preferred)

```typescript
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

// app.ts
import { add } from "./math";
console.log(add(2, 3)); // 5
```

### Global Objects in Node.js

Unlike browsers, Node.js has different globals:

```typescript
global              // Global namespace (instead of window)
__dirname           // Current directory path
__filename          // Current file path
process             // Process information (args, env, exit, etc.)
Buffer              // Raw binary data
console             // Logging (log, error, warn, etc.)
setTimeout/setInterval  // Timer functions
```

### The `process` Object

The `process` object provides access to Node.js runtime information:

```typescript
// Environment variables
console.log(process.env.NODE_ENV);

// Command-line arguments
console.log(process.argv);

// Exit the process
process.exit(0);

// Handle termination signals
process.on("SIGTERM", () => {
  console.log("Cleaning up...");
  process.exit(0);
});

// Current working directory
console.log(process.cwd());

// Node version
console.log(process.version);
```

---

## Event Emitters: Building Blocks of Node.js

Many Node.js objects are **Event Emitters** that emit named events that cause Function objects ("listeners") to be called.

```typescript
import { EventEmitter } from "events";

class UserManager extends EventEmitter {
  createUser(name: string): void {
    // Do stuff...
    this.emit("userCreated", { name });
  }

  deleteUser(id: number): void {
    // Do stuff...
    this.emit("userDeleted", { id });
  }
}

const manager = new UserManager();

// Listen for events
manager.on("userCreated", (user) => {
  console.log(`Welcome, ${user.name}!`);
});

manager.on("userDeleted", (data) => {
  console.log(`User ${data.id} removed`);
});

manager.createUser("Alice"); // Emits event
manager.deleteUser(1); // Emits event
```

---

## Streams: Handling Large Data

**Streams** are objects that let you read/write data in chunks rather than loading everything into memory at once. Essential for handling large files or real-time data.

```typescript
import fs from "fs";

// Reading a large file in chunks
const readStream = fs.createReadStream("large-file.txt", {
  encoding: "utf8",
  highWaterMark: 16 * 1024, // 16KB chunks
});

readStream.on("data", (chunk) => {
  console.log(`Received ${chunk.length} bytes of data`);
});

readStream.on("end", () => {
  console.log("No more data to read");
});

readStream.on("error", (error) => {
  console.error("Error reading file:", error);
});
```

### Writable Stream

```typescript
const writeStream = fs.createWriteStream("output.txt");

writeStream.write("Hello, ");
writeStream.write("World!");
writeStream.end(); // No more data

writeStream.on("finish", () => {
  console.log("File written successfully");
});
```

### Pipe: Connecting Streams

Streams can be "piped" together, automatically managing flow:

```typescript
// Copy a file efficiently
fs.createReadStream("input.txt")
  .pipe(fs.createWriteStream("output.txt"))
  .on("finish", () => console.log("File copied!"));

// Transform data while piping
import zlib from "zlib";
fs.createReadStream("input.txt")
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream("input.txt.gz"))
  .on("finish", () => console.log("File compressed!"));
```

---

## Callbacks, Promises, and Async/Await

### Callbacks (Callback Hell)

Callbacks are functions passed as arguments to other functions, which are then executed laterâ€”often after a task completes or an event occurs. They allow you to define custom behavior that should run once a certain operation finishes.

```ts
// Define a callback type
type Callback = (error: Error | null, result?: string) => void;

// Function that accepts a callback
function fetchData(callback: Callback): void {
  setTimeout(() => {
    const data = "Hello from server!";
    callback(null, data); // invoke callback after async task
  }, 1000);
}

// Use the function with a callback
fetchData((err, result) => {
  if (err) {
    console.error("Error:", err.message);
  } else {
    console.log("Result:", result);
  }
});
```

**Callback Hell** is the situation where code becomes messy and hard to read because of too many nested callbacks, often forming a â€œpyramid of doom.â€ It happens when each asynchronous operation depends on the result of the previous one, forcing you to nest functions inside functions.

```typescript
fs.readFile("file1.txt", (err, data1) => {
  if (err) throw err;
  fs.readFile("file2.txt", (err, data2) => {
    if (err) throw err;
    fs.readFile("file3.txt", (err, data3) => {
      // âŒ Nested callbacks become hard to read
      console.log(data1, data2, data3);
    });
  });
});
```

### Promises (Better)

A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. A way to think about it is a placeholder for a value that isnâ€™t available yet but will be resolved in the future.

```typescript
import { promises as fs } from "fs";

fs.readFile("file1.txt", "utf8")
  .then((data1) => {
    return fs.readFile("file2.txt", "utf8");
  })
  .then((data2) => {
    return fs.readFile("file3.txt", "utf8");
  })
  .then((data3) => {
    console.log(data3);
  })
  .catch((err) => console.error(err));
```

### Async/Await (Best)

The `async` and `await` are modern TypeScript/JavaScript keywords that make working with Promises much cleaner and easier to read.

- **async:** Declares that a function is asynchronous. It always returns a Promise, even if you return a plain value.
- **await:** Pauses execution inside an async function until the Promise resolves (or rejects). It lets you write asynchronous code that looks synchronous.ðŸ“˜ Example

**Using Promises**

```ts
function fetchData(): Promise<string> {
  return new Promise((resolve) => {
    setTimeout(() => resolve("Data loaded!"), 1000);
  });
}

fetchData()
  .then((result) => console.log(result))
  .catch((err) => console.error(err));
```

**Using Async/Await**

```ts
async function run() {
  try {
    const result = await fetchData(); // waits until Promise resolves
    console.log(result);
  } catch (err) {
    console.error("Error:", (err as Error).message);
  }
}

run();
```

```typescript
import { promises as fs } from "fs";

async function readFiles(): Promise<void> {
  try {
    const data1 = await fs.readFile("file1.txt", "utf8");
    const data2 = await fs.readFile("file2.txt", "utf8");
    const data3 = await fs.readFile("file3.txt", "utf8");
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}

readFiles();
```

---

## Summary

- **Node.js** is a JavaScript runtime powered by V8 and libuv.
- **Event Loop** is what enables non-blocking I/Oâ€”the core of Node's performance.
- **Modules** help organize code and are essential for building scalable applications.
- **Event Emitters**, **Streams**, and **Promises** are fundamental concepts you'll use constantly.
- **Async/await** is the modern way to handle asynchronous operations cleanly.
