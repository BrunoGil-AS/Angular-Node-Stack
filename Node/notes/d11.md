# Day 11: Node.js Fundamentals - The Runtime & Event Loop

## Understanding Node.js

Node.js is a **JavaScript runtime environment** that allows you to execute JavaScript outside the browser. It was built on top of Chrome's V8 engine and designed specifically for building scalable network applications on the server side.

### Why Node.js?

- **JavaScript Everywhere:** Use the same language for frontend and backend.
- **Non-blocking I/O:** Efficiently handle thousands of concurrent connections.
- **Event-Driven:** Perfect for real-time applications (chat, notifications, dashboards).
- **NPM Ecosystem:** Massive package repository for rapid development.

---

## The Node.js Runtime

### What is a Runtime?

A runtime is an **execution environment** that provides the necessary infrastructure to run code. It includes:

1. **V8 Engine:** Converts JavaScript to machine code.
2. **libuv Library:** Handles async I/O operations (the heart of Node's non-blocking nature).
3. **Standard Library:** Built-in modules like `fs`, `http`, `path`, etc.

```plain
┌─────────────────────────────────┐
│     Your JavaScript Code        │
└────────────┬────────────────────┘
             │
┌────────────▼────────────────────┐
│    Node.js Runtime              │
│  ┌───────────────────────────┐  │
│  │   V8 Engine               │  │
│  │ (JS → Machine Code)       │  │
│  └───────────────────────────┘  │
│  ┌───────────────────────────┐  │
│  │   libuv Library           │  │
│  │ (Async I/O, Event Loop)   │  │
│  └───────────────────────────┘  │
│  ┌───────────────────────────┐  │
│  │   Standard Library        │  │
│  │ (fs, http, path, etc.)    │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
             │
┌────────────▼────────────────────┐
│   Operating System              │
│ (File System, Network, Threads) │
└─────────────────────────────────┘
```

---

## The Event Loop: Heart of Node.js

The **Event Loop** is what makes Node.js non-blocking. It's a mechanism that executes JavaScript callbacks and handles I/O operations efficiently.

### The Problem: Blocking Operations

In traditional **blocking I/O**, reading a file looks like this:

```javascript
// ❌ BLOCKING - application is frozen while waiting
const data = fs.readFileSync("large-file.txt"); // Waits here...
console.log(data); // Only executed after file is fully read
doOtherWork(); // Stuck waiting!
```

### The Solution: Non-Blocking I/O with Callbacks

```javascript
// ✅ NON-BLOCKING - application continues while waiting
fs.readFile("large-file.txt", (err, data) => {
  if (err) throw err;
  console.log(data); // Executed when file is ready
});
console.log("File reading started, continuing with other work...");
doOtherWork(); // Runs immediately!
```

### How the Event Loop Works (Simplified)

```plain
1. JavaScript Code Execution
   ↓
2. Check for Completed Async Operations (timers, I/O)
   ↓
3. Execute Callbacks for Completed Operations
   ↓
4. Check for More Work
   ├─ If yes → Go to step 1
   └─ If no → Exit
```

### Event Loop Phases (Detailed)

Node's event loop has several phases that execute in order:

```plain
┌─────────────────────────────────────────────────┐
│         Event Loop Execution Order              │
├─────────────────────────────────────────────────┤
│ 1. timers                                       │
│    (setTimeout, setInterval callbacks)          │
├─────────────────────────────────────────────────┤
│ 2. pending callbacks                            │
│    (I/O errors, some system operations)         │
├─────────────────────────────────────────────────┤
│ 3. idle, prepare                                │
│    (Internal use)                               │
├─────────────────────────────────────────────────┤
│ 4. poll                                         │
│    (I/O events - files, network, etc.)          │
├─────────────────────────────────────────────────┤
│ 5. check                                        │
│    (setImmediate callbacks)                     │
├─────────────────────────────────────────────────┤
│ 6. close callbacks                              │
│    (Socket closeups, connection terminations)   │
└─────────────────────────────────────────────────┘
```

#### Example: Understanding Event Loop Order

```typescript
console.log("1. Synchronous start");

setTimeout(() => {
  console.log("2. setTimeout (timers phase)");
}, 0);

setImmediate(() => {
  console.log("3. setImmediate (check phase)");
});

Promise.resolve().then(() => {
  console.log("4. Promise (Microtask Queue)");
});

console.log("5. Synchronous end");

// Output:
// 1. Synchronous start
// 5. Synchronous end
// 4. Promise (Microtask Queue)
// 2. setTimeout (timers phase)
// 3. setImmediate (check phase)
```

### Key Concept: Microtask Queue vs. Macrotask Queue

The event loop also manages two special queues:

```plain
┌──────────────────────────────────────────────────────┐
│              Callback Execution                      │
├──────────────────────────────────────────────────────┤
│ 1. Execute all Synchronous Code                     │
│ 2. Execute all Microtasks (Promises, process.nextTick)
│ 3. Execute ONE Macrotask (setTimeout, setInterval)  │
│ 4. Execute all Microtasks again                     │
│ 5. Repeat from step 3                               │
└──────────────────────────────────────────────────────┘
```

**Microtasks** (High Priority):

- Promise callbacks (`.then()`, `.catch()`)
- `process.nextTick()`
- `queueMicrotask()`

**Macrotasks** (Lower Priority):

- `setTimeout()`
- `setInterval()`
- I/O operations
- `setImmediate()`

---

## Node.js Modules

Node.js uses a **module system** to organize code. Each file is a module that can export and import functionality.

### CommonJS vs. ES Modules

#### CommonJS (Traditional)

```typescript
// math.js
function add(a: number, b: number): number {
  return a + b;
}

module.exports = { add };

// app.js
const { add } = require("./math");
console.log(add(2, 3)); // 5
```

#### ES Modules (Modern, preferred)

```typescript
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

// app.ts
import { add } from "./math";
console.log(add(2, 3)); // 5
```

### Global Objects in Node.js

Unlike browsers, Node.js has different globals:

```typescript
global              // Global namespace (instead of window)
__dirname           // Current directory path
__filename          // Current file path
process             // Process information (args, env, exit, etc.)
Buffer              // Raw binary data
console             // Logging (log, error, warn, etc.)
setTimeout/setInterval  // Timer functions
```

### The `process` Object

The `process` object provides access to Node.js runtime information:

```typescript
// Environment variables
console.log(process.env.NODE_ENV);

// Command-line arguments
console.log(process.argv);

// Exit the process
process.exit(0);

// Handle termination signals
process.on("SIGTERM", () => {
  console.log("Cleaning up...");
  process.exit(0);
});

// Current working directory
console.log(process.cwd());

// Node version
console.log(process.version);
```

---

## Event Emitters: Building Blocks of Node.js

Many Node.js objects are **Event Emitters** that emit named events that cause Function objects ("listeners") to be called.

```typescript
import { EventEmitter } from "events";

class UserManager extends EventEmitter {
  createUser(name: string): void {
    // Do stuff...
    this.emit("userCreated", { name });
  }

  deleteUser(id: number): void {
    // Do stuff...
    this.emit("userDeleted", { id });
  }
}

const manager = new UserManager();

// Listen for events
manager.on("userCreated", (user) => {
  console.log(`Welcome, ${user.name}!`);
});

manager.on("userDeleted", (data) => {
  console.log(`User ${data.id} removed`);
});

manager.createUser("Alice"); // Emits event
manager.deleteUser(1); // Emits event
```

---

## Streams: Handling Large Data

**Streams** are objects that let you read/write data in chunks rather than loading everything into memory at once. Essential for handling large files or real-time data.

```typescript
import fs from "fs";

// Reading a large file in chunks
const readStream = fs.createReadStream("large-file.txt", {
  encoding: "utf8",
  highWaterMark: 16 * 1024, // 16KB chunks
});

readStream.on("data", (chunk) => {
  console.log(`Received ${chunk.length} bytes of data`);
});

readStream.on("end", () => {
  console.log("No more data to read");
});

readStream.on("error", (error) => {
  console.error("Error reading file:", error);
});
```

### Writable Stream

```typescript
const writeStream = fs.createWriteStream("output.txt");

writeStream.write("Hello, ");
writeStream.write("World!");
writeStream.end(); // No more data

writeStream.on("finish", () => {
  console.log("File written successfully");
});
```

### Pipe: Connecting Streams

Streams can be "piped" together, automatically managing flow:

```typescript
// Copy a file efficiently
fs.createReadStream("input.txt")
  .pipe(fs.createWriteStream("output.txt"))
  .on("finish", () => console.log("File copied!"));

// Transform data while piping
import zlib from "zlib";
fs.createReadStream("input.txt")
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream("input.txt.gz"))
  .on("finish", () => console.log("File compressed!"));
```

---

## Callbacks, Promises, and Async/Await

### Callbacks (Callback Hell)

```typescript
fs.readFile("file1.txt", (err, data1) => {
  if (err) throw err;
  fs.readFile("file2.txt", (err, data2) => {
    if (err) throw err;
    fs.readFile("file3.txt", (err, data3) => {
      // ❌ Nested callbacks become hard to read
      console.log(data1, data2, data3);
    });
  });
});
```

### Promises (Better)

```typescript
import { promises as fs } from "fs";

fs.readFile("file1.txt", "utf8")
  .then((data1) => {
    return fs.readFile("file2.txt", "utf8");
  })
  .then((data2) => {
    return fs.readFile("file3.txt", "utf8");
  })
  .then((data3) => {
    console.log(data3);
  })
  .catch((err) => console.error(err));
```

### Async/Await (Best)

```typescript
import { promises as fs } from "fs";

async function readFiles(): Promise<void> {
  try {
    const data1 = await fs.readFile("file1.txt", "utf8");
    const data2 = await fs.readFile("file2.txt", "utf8");
    const data3 = await fs.readFile("file3.txt", "utf8");
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}

readFiles();
```

---

## Summary

- **Node.js** is a JavaScript runtime powered by V8 and libuv.
- **Event Loop** is what enables non-blocking I/O—the core of Node's performance.
- **Modules** help organize code and are essential for building scalable applications.
- **Event Emitters**, **Streams**, and **Promises** are fundamental concepts you'll use constantly.
- **Async/await** is the modern way to handle asynchronous operations cleanly.
