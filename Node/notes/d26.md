# Database Connection - Complete Guide (TypeScript)

## NoSQL and MongoDB

### What is NoSQL?

**NoSQL** stands for "Not Only SQL" - databases that don't use traditional table-based relational structures.

#### Key Characteristics:

- **Flexible Schema**: No rigid table structure
- **JSON-like Documents**: Data stored in a format similar to JavaScript objects
- **Scalability**: Designed to handle large amounts of data
- **Dynamic**: Easy to modify data structure without migrations

### What is MongoDB?

MongoDB is a **document-oriented NoSQL database** that stores data in JSON-like documents called BSON (Binary JSON).

#### Why MongoDB for JavaScript Developers?

**1. Natural Data Format**

```typescript
// TypeScript Interface
interface User {
  name: string;
  email: string;
  age: number;
  hobbies: string[];
}

// JavaScript Object
const user: User = {
  name: "Alice",
  email: "alice@example.com",
  age: 25,
  hobbies: ["reading", "coding"]
};

// MongoDB Document (almost identical!)
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "name": "Alice",
  "email": "alice@example.com",
  "age": 25,
  "hobbies": ["reading", "coding"]
}
```

**2. No Complex Joins**
Unlike SQL databases, MongoDB stores related data together:

```typescript
// SQL approach (multiple tables)
// Users table: id, name, email
// Posts table: id, user_id, title, content

// MongoDB approach (embedded documents)
interface UserWithPosts {
  name: string;
  email: string;
  posts: {
    title: string;
    content: string;
  }[];
}

const userDoc: UserWithPosts = {
  name: "Alice",
  email: "alice@example.com",
  posts: [
    { title: "My First Post", content: "Hello world!" },
    { title: "Learning MongoDB", content: "It's great!" },
  ],
};
```

**3. Flexible Schema**

```typescript
// User 1
{ name: "Alice", email: "alice@example.com", age: 25 }

// User 2 - different fields, no problem!
{ name: "Bob", email: "bob@example.com", country: "USA", verified: true }
```

### MongoDB Document Structure

```typescript
interface MongoDocument {
  _id: ObjectId; // Unique identifier (auto-generated)
  field1: string; // String
  field2: number; // Number
  field3: boolean; // Boolean
  field4: string[]; // Array
  field5: {
    // Nested object
    nestedField: string;
  };
  createdAt: Date; // Date
}
```

### Collections vs Tables

| SQL (Relational) | MongoDB (NoSQL) |
| ---------------- | --------------- |
| Database         | Database        |
| Table            | Collection      |
| Row              | Document        |
| Column           | Field           |

---

## ODM - Mongoose

### What is an ODM?

**ODM** stands for **Object Document Mapper**. It's a library that maps TypeScript/JavaScript objects to MongoDB documents.

**Think of it as a translator:**

- TypeScript Objects ‚ÜîÔ∏è MongoDB Documents

### What is Mongoose?

Mongoose is the most popular ODM for MongoDB in Node.js. It provides:

1. **Schema Definition**: Structure for your data with TypeScript types
2. **Validation**: Ensure data meets requirements
3. **Middleware**: Run code before/after operations
4. **Query Building**: Easier database queries
5. **Type Casting**: Automatic data type conversion

### Why Use Mongoose?

**Without Mongoose (Native MongoDB Driver):**

```typescript
// More verbose, less structure, no type safety
const db = client.db("myapp");
await db.collection("users").insertOne({
  name: "Alice",
  email: "alice@example.com",
  age: "25", // Oops! String instead of number - no validation
});
```

**With Mongoose:**

```typescript
// Structured, validated, type-safe
const user = new User({
  name: "Alice",
  email: "alice@example.com",
  age: "25", // Automatically converted to number!
});
await user.save();
```

### Mongoose Core Concepts

#### 1. TypeScript Interface + Schema

A **Schema** defines the structure and rules for documents in a collection.

```typescript
import mongoose, { Document, Schema } from "mongoose";

// 1. Define TypeScript interface for type safety
interface IUser {
  name: string;
  email: string;
  age: number;
  hobbies: string[];
  address: {
    street: string;
    city: string;
    country: string;
  };
  isActive: boolean;
  createdAt: Date;
}

// 2. Extend Document for Mongoose methods
interface IUserDocument extends IUser, Document {}

// 3. Create Schema
const userSchema = new Schema<IUserDocument>({
  name: {
    type: String, // Data type
    required: true, // Validation: must be provided
    trim: true, // Remove whitespace
  },
  email: {
    type: String,
    required: [true, "Email is required"], // Custom error message
    unique: true, // No duplicates allowed
    lowercase: true, // Convert to lowercase
    match: [/.+@.+\..+/, "Please enter a valid email"], // Regex validation
  },
  age: {
    type: Number,
    min: [0, "Age cannot be negative"],
    max: [120, "Age seems unrealistic"],
  },
  hobbies: [String], // Array of strings
  address: {
    // Nested object
    street: String,
    city: String,
    country: String,
  },
  isActive: {
    type: Boolean,
    default: true, // Default value
  },
  createdAt: {
    type: Date,
    default: Date.now, // Auto-set current date
  },
});
```

#### 2. Model

A **Model** is a compiled version of a Schema. It's a constructor function that creates and reads documents.

```typescript
// Create a model from the schema
const User = mongoose.model<IUserDocument>("User", userSchema);
// 'User' is the model name
// MongoDB will create a collection named 'users' (lowercase, pluralized)
```

**Model provides methods to:**

- Create documents: `new User()`, `User.create()`
- Read documents: `User.find()`, `User.findById()`
- Update documents: `User.updateOne()`, `User.findByIdAndUpdate()`
- Delete documents: `User.deleteOne()`, `User.findByIdAndDelete()`

### Complete Schema Example with Common Features

```typescript
import mongoose, { Document, Schema } from "mongoose";

// TypeScript interface
interface IProduct {
  name: string;
  description: string;
  price: number;
  category: "Electronics" | "Clothing" | "Food" | "Books";
  inStock: boolean;
  tags: string[];
  ratings: {
    user: string;
    score: number;
    comment: string;
  }[];
  seller: mongoose.Types.ObjectId; // Reference to another document
  createdAt?: Date;
  updatedAt?: Date;
}

// Extend Document
interface IProductDocument extends IProduct, Document {}

// Create Schema
const productSchema = new Schema<IProductDocument>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: [100, "Product name cannot exceed 100 characters"],
    },
    description: {
      type: String,
      required: true,
    },
    price: {
      type: Number,
      required: true,
      min: [0, "Price cannot be negative"],
    },
    category: {
      type: String,
      enum: ["Electronics", "Clothing", "Food", "Books"], // Limited options
      required: true,
    },
    inStock: {
      type: Boolean,
      default: true,
    },
    tags: [String],
    ratings: [
      {
        user: String,
        score: {
          type: Number,
          min: 1,
          max: 5,
        },
        comment: String,
      },
    ],
    seller: {
      type: Schema.Types.ObjectId, // Reference to another document
      ref: "User", // References the User model
    },
  },
  {
    timestamps: true, // Automatically adds createdAt and updatedAt fields
  }
);

// Create model
const Product = mongoose.model<IProductDocument>("Product", productSchema);

export { Product, IProduct, IProductDocument };
```

### Schema Types Reference

| Type       | TypeScript Type           | Example                     | Description                   |
| ---------- | ------------------------- | --------------------------- | ----------------------------- |
| `String`   | `string`                  | `name: String`              | Text data                     |
| `Number`   | `number`                  | `age: Number`               | Numeric data                  |
| `Boolean`  | `boolean`                 | `isActive: Boolean`         | true/false                    |
| `Date`     | `Date`                    | `createdAt: Date`           | Date and time                 |
| `Array`    | `T[]`                     | `tags: [String]`            | List of items                 |
| `Object`   | `object`                  | `address: { city: String }` | Nested object                 |
| `ObjectId` | `mongoose.Types.ObjectId` | `Schema.Types.ObjectId`     | Reference to another document |
| `Mixed`    | `any`                     | `Schema.Types.Mixed`        | Any data type                 |

---

## Topic 3: Database Connection

### Initial Setup

#### Step 1: Install Dependencies

```bash
npm install mongoose dotenv
npm install --save-dev @types/node typescript ts-node nodemon
```

- **mongoose**: ODM library for MongoDB
- **dotenv**: Load environment variables from `.env` file
- **@types/node**: TypeScript types for Node.js
- **typescript**: TypeScript compiler
- **ts-node**: Run TypeScript directly
- **nodemon**: Auto-restart server on changes

#### Step 2: TypeScript Configuration

Create `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

#### Step 3: Get MongoDB Connection String

**Option A: MongoDB Atlas (Cloud - Recommended for beginners)**

1. Go to [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)
2. Create a free account
3. Create a new cluster (Free tier available)
4. Click "Connect" ‚Üí "Connect your application"
5. Copy the connection string:
   ```
   mongodb+srv://<username>:<password>@cluster0.xxxxx.mongodb.net/<database>?retryWrites=true&w=majority
   ```

**Option B: Local MongoDB**

1. Install MongoDB locally
2. Connection string:
   ```
   mongodb://localhost:27017/mydatabase
   ```

#### Step 4: Create Environment Variables File

Create a file named `.env` in your project root:

```env
# .env file
MONGO_URI=mongodb+srv://username:password@cluster0.xxxxx.mongodb.net/mydatabase?retryWrites=true&w=majority
PORT=3000
NODE_ENV=development
```

**‚ö†Ô∏è Security Note:** Add `.env` to your `.gitignore` file to prevent committing sensitive data!

```bash
# .gitignore
node_modules/
dist/
.env
```

#### Step 5: Project Structure

```
my-project/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.ts       # Database connection logic
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.ts           # Mongoose models
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.ts     # API routes
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ environment.d.ts  # Type definitions for env variables
‚îÇ   ‚îî‚îÄ‚îÄ server.ts             # Main application file
‚îú‚îÄ‚îÄ .env                      # Environment variables
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ tsconfig.json             # TypeScript configuration
‚îî‚îÄ‚îÄ package.json
```

### Environment Types (Type Safety)

Create `src/types/environment.d.ts`:

```typescript
// src/types/environment.d.ts
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      MONGO_URI: string;
      PORT: string;
      NODE_ENV: "development" | "production" | "test";
    }
  }
}

export {};
```

### Connection Implementation

#### Method 1: Basic Connection (server.ts)

```typescript
// src/server.ts
import dotenv from "dotenv";
import mongoose from "mongoose";
import express, { Application } from "express";

// Load environment variables
dotenv.config();

// Connection string from environment variable
const MONGO_URI: string = process.env.MONGO_URI;
const PORT: number = parseInt(process.env.PORT) || 3000;

// Connect to MongoDB
mongoose
  .connect(MONGO_URI)
  .then(() => {
    console.log("‚úÖ Connected to MongoDB successfully!");
  })
  .catch((error: Error) => {
    console.error("‚ùå MongoDB connection error:", error);
    process.exit(1); // Exit the application if connection fails
  });

// Your Express app
const app: Application = express();

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

#### Method 2: Separate Connection File (Recommended)

**src/config/database.ts**

```typescript
// src/config/database.ts
import mongoose from "mongoose";

const connectDB = async (): Promise<void> => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);

    console.log(`‚úÖ MongoDB Connected: ${conn.connection.host}`);
    console.log(`üìä Database Name: ${conn.connection.name}`);
  } catch (error) {
    if (error instanceof Error) {
      console.error(`‚ùå Error: ${error.message}`);
    }
    process.exit(1); // Exit process with failure
  }
};

export default connectDB;
```

**src/server.ts**

```typescript
// src/server.ts
import dotenv from "dotenv";
import express, { Application } from "express";
import connectDB from "./config/database";

// Load environment variables
dotenv.config();

// Connect to database
connectDB();

const app: Application = express();

app.get("/", (req, res) => {
  res.send("Server is running!");
});

const PORT: number = parseInt(process.env.PORT) || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Server is running on port ${PORT}`);
});
```

### Connection Events and Monitoring

```typescript
// src/config/database.ts
import mongoose from "mongoose";

const connectDB = async (): Promise<void> => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("‚úÖ MongoDB Connected");
  } catch (error) {
    if (error instanceof Error) {
      console.error("‚ùå Connection Error:", error.message);
    }
    process.exit(1);
  }
};

// Connection event listeners
mongoose.connection.on("connected", () => {
  console.log("Mongoose connected to DB");
});

mongoose.connection.on("error", (err: Error) => {
  console.error("Mongoose connection error:", err);
});

mongoose.connection.on("disconnected", () => {
  console.log("Mongoose disconnected");
});

// Graceful shutdown
process.on("SIGINT", async () => {
  await mongoose.connection.close();
  console.log("Mongoose connection closed due to app termination");
  process.exit(0);
});

export default connectDB;
```

### Using Models After Connection

**src/models/User.ts**

```typescript
// src/models/User.ts
import mongoose, { Document, Schema } from "mongoose";

// 1. Define the interface
export interface IUser {
  name: string;
  email: string;
  password: string;
  role: "user" | "admin";
  createdAt?: Date;
  updatedAt?: Date;
}

// 2. Extend Document for Mongoose
export interface IUserDocument extends IUser, Document {}

// 3. Create Schema
const userSchema = new Schema<IUserDocument>(
  {
    name: {
      type: String,
      required: [true, "Name is required"],
      trim: true,
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [6, "Password must be at least 6 characters"],
    },
    role: {
      type: String,
      enum: ["user", "admin"],
      default: "user",
    },
  },
  {
    timestamps: true,
  }
);

// 4. Create and export model
export const User = mongoose.model<IUserDocument>("User", userSchema);
```

**Using the model in your application:**

```typescript
// src/routes/userRoutes.ts
import express, { Request, Response, Router } from "express";
import { User, IUser } from "../models/User";

const router: Router = express.Router();

// Create a new user
router.post("/users", async (req: Request, res: Response): Promise<void> => {
  try {
    const userData: IUser = req.body;
    const user = new User(userData);

    await user.save();
    res.status(201).json(user);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
});

// Get all users
router.get("/users", async (req: Request, res: Response): Promise<void> => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});

// Get user by ID
router.get("/users/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      res.status(404).json({ error: "User not found" });
      return;
    }
    res.json(user);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});

// Update user
router.put("/users/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    const user = await User.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true } // Return updated doc, run validators
    );
    if (!user) {
      res.status(404).json({ error: "User not found" });
      return;
    }
    res.json(user);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
});

// Delete user
router.delete(
  "/users/:id",
  async (req: Request, res: Response): Promise<void> => {
    try {
      const user = await User.findByIdAndDelete(req.params.id);
      if (!user) {
        res.status(404).json({ error: "User not found" });
        return;
      }
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      if (error instanceof Error) {
        res.status(500).json({ error: error.message });
      }
    }
  }
);

export default router;
```

---

## Complete Working Example

Here's a full working example combining everything:

**package.json**

```json
{
  "name": "mongodb-typescript-example",
  "version": "1.0.0",
  "main": "dist/server.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "nodemon --exec ts-node src/server.ts",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.0",
    "typescript": "^5.3.3",
    "ts-node": "^10.9.2",
    "nodemon": "^3.0.1"
  }
}
```

**.env**

```env
MONGO_URI=mongodb+srv://myuser:mypassword@cluster0.xxxxx.mongodb.net/myapp?retryWrites=true&w=majority
PORT=3000
NODE_ENV=development
```

**tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

**src/types/environment.d.ts**

```typescript
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      MONGO_URI: string;
      PORT: string;
      NODE_ENV: "development" | "production" | "test";
    }
  }
}

export {};
```

**src/config/database.ts**

```typescript
import mongoose from "mongoose";

const connectDB = async (): Promise<void> => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`‚úÖ MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    if (error instanceof Error) {
      console.error(`‚ùå Error: ${error.message}`);
    }
    process.exit(1);
  }
};

export default connectDB;
```

**src/models/Task.ts**

```typescript
import mongoose, { Document, Schema } from "mongoose";

export interface ITask {
  title: string;
  description: string;
  completed: boolean;
  priority: "low" | "medium" | "high";
  dueDate?: Date;
  createdAt?: Date;
  updatedAt?: Date;
}

export interface ITaskDocument extends ITask, Document {}

const taskSchema = new Schema<ITaskDocument>(
  {
    title: {
      type: String,
      required: [true, "Task title is required"],
      trim: true,
    },
    description: {
      type: String,
      default: "",
    },
    completed: {
      type: Boolean,
      default: false,
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high"],
      default: "medium",
    },
    dueDate: {
      type: Date,
    },
  },
  {
    timestamps: true,
  }
);

export const Task = mongoose.model<ITaskDocument>("Task", taskSchema);
```

**src/server.ts**

```typescript
import dotenv from "dotenv";
import express, { Application, Request, Response } from "express";
import connectDB from "./config/database";
import { Task, ITask } from "./models/Task";

// Load environment variables
dotenv.config();

// Connect to database
connectDB();

const app: Application = express();

// Middleware
app.use(express.json());

// Routes
app.get("/", (req: Request, res: Response): void => {
  res.json({ message: "Task API is running" });
});

// Create task
app.post("/tasks", async (req: Request, res: Response): Promise<void> => {
  try {
    const taskData: ITask = req.body;
    const task = await Task.create(taskData);
    res.status(201).json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
});

// Get all tasks
app.get("/tasks", async (req: Request, res: Response): Promise<void> => {
  try {
    const tasks = await Task.find().sort({ createdAt: -1 });
    res.json(tasks);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});

// Get single task
app.get("/tasks/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    const task = await Task.findById(req.params.id);
    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }
    res.json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});

// Update task
app.put("/tasks/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    const task = await Task.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }
    res.json(task);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    }
  }
});

// Delete task
app.delete("/tasks/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    const task = await Task.findByIdAndDelete(req.params.id);
    if (!task) {
      res.status(404).json({ error: "Task not found" });
      return;
    }
    res.json({ message: "Task deleted successfully" });
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});

const PORT: number = parseInt(process.env.PORT) || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
});
```

---

## Modern Alternatives & Trends (2024-2025)

While **Mongoose + MongoDB** remains very popular and widely used, the Node.js ecosystem has evolved with new approaches:

### 1. **Prisma** (‚≠ê Trending Choice)

Prisma is a modern ORM that works with PostgreSQL, MySQL, SQLite, MongoDB, and more.

**Why developers love it:**

- Type-safe database queries (TypeScript first)
- Auto-generated types
- Intuitive query API
- Great migration system
- Works with both SQL and NoSQL

**Example:**

```typescript
// schema.prisma
model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  name  String
  posts Post[]
}

// Generated TypeScript types automatically!
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

// Fully type-safe
const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    name: 'Alice',
  }
});
```

**When to use:** TypeScript projects, need type safety, want excellent developer experience

### 2. **Drizzle ORM** (‚≠ê New & Fast)

A lightweight, TypeScript-first ORM that's gaining rapid adoption.

**Why it's trending:**

- Extremely lightweight
- SQL-like syntax
- Zero runtime overhead
- Edge-ready (works with serverless)
- Better performance than Prisma

**Example:**

```typescript
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, serial, text } from "drizzle-orm/pg-core";

const users = pgTable("users", {
  id: serial("id").primaryKey(),
  name: text("name"),
});

const db = drizzle(pool);
await db.insert(users).values({ name: "Alice" });
```

**When to use:** Performance-critical apps, edge functions, TypeScript projects

### 3. **Native MongoDB Driver** (Minimal Approach)

Using MongoDB's official driver without Mongoose.

**Why some choose it:**

- Less abstraction, more control
- Smaller bundle size
- Direct access to MongoDB features
- No schema overhead

**Example:**

```typescript
import { MongoClient, Db, Collection } from "mongodb";

interface User {
  name: string;
  email: string;
}

const client = new MongoClient(process.env.MONGO_URI);
await client.connect();
const db: Db = client.db("myapp");
const users: Collection<User> = db.collection<User>("users");

await users.insertOne({ name: "Alice", email: "alice@example.com" });
```

**When to use:** Simple projects, need maximum flexibility, prefer minimal dependencies

### 4. **PostgreSQL with ORMs** (SQL Renaissance)

PostgreSQL is experiencing a renaissance in Node.js world.

**Popular combinations:**

- **PostgreSQL + Prisma**
- **PostgreSQL + Drizzle**
- **PostgreSQL + TypeORM**
- **PostgreSQL + Knex.js**

**Why the shift back to SQL:**

- PostgreSQL has JSON support (best of both worlds)
- ACID transactions
- Better for complex relationships
- Mature ecosystem
- Free hosting options (Supabase, Neon, Railway)

**Example with Supabase:**

```typescript
import { createClient } from "@supabase/supabase-js";

interface User {
  name: string;
  email: string;
}

const supabase = createClient(URL, KEY);
const { data, error } = await supabase
  .from("users")
  .insert<User>({ name: "Alice", email: "alice@example.com" });
```

### 5. **Edge-Native Databases**

New databases designed for serverless/edge computing:

- **Turso** (SQLite for the edge)
- **PlanetScale** (MySQL-compatible, serverless)
- **Cloudflare D1** (SQLite at the edge)
- **Xata** (Serverless PostgreSQL)

### Comparison Table

| Solution                | Type           | Pros                                      | Cons                               | Best For                              |
| ----------------------- | -------------- | ----------------------------------------- | ---------------------------------- | ------------------------------------- |
| **Mongoose + MongoDB**  | NoSQL + ODM    | Easy for JS devs, flexible schema, mature | Less type-safe, can be verbose     | Traditional apps, rapid prototyping   |
| **Prisma**              | ORM (Multi-DB) | Type-safe, great DX, migrations           | Slower than others, larger runtime | TypeScript projects, teams            |
| **Drizzle**             | ORM (SQL)      | Lightweight, fast, type-safe              | Newer, smaller community           | Performance-critical, edge            |
| **PostgreSQL + Prisma** | SQL + ORM      | Relational power + modern DX              | Learning curve for SQL             | Complex relationships, data integrity |
| **Native Drivers**      | Direct         | Maximum control, minimal deps             | More boilerplate, no validation    | Simple apps, microservices            |

### 2024-2025 Trends

**üî• What's Hot:**

1. **Type Safety First** - TypeScript adoption driving Prisma & Drizzle growth
2. **Edge Computing** - Databases that work on Cloudflare Workers, Vercel Edge
3. **Developer Experience** - Auto-completion, migrations, type generation
4. **SQL is Back** - PostgreSQL gaining popularity over MongoDB for new projects
5. **Serverless-First** - Databases designed for serverless architectures

**üìä Market Reality:**

- **MongoDB + Mongoose**: Still #1 in total usage, especially in existing projects
- **Prisma**: Fastest growing, especially in new TypeScript projects
- **PostgreSQL**: Becoming default choice for new serious applications
- **Drizzle**: Rising star in 2024, especially for performance-focused devs

### Modern Stack Examples

**Stack 1: Maximum Type Safety**

```
TypeScript + Prisma + PostgreSQL + tRPC
```

**Stack 2: Edge-First**

```
TypeScript + Drizzle + Turso/D1 + Hono
```

**Stack 3: Traditional Reliable**

```
TypeScript + Mongoose + MongoDB Atlas
```

**Stack 4: Rapid Development**

```
Next.js + Prisma + Supabase (PostgreSQL)
```

### Should You Still Use Mongoose?

**‚úÖ YES, if:**

- You're working on an existing Mongoose project
- Your team knows MongoDB well
- You need flexible schemas (frequent data structure changes)
- You're prototyping quickly
- You prefer document-based thinking
- You're learning backend development (it's beginner-friendly)

**ü§î CONSIDER ALTERNATIVES, if:**

- Starting a new TypeScript project (‚Üí Prisma or Drizzle)
- Need strong type safety (‚Üí Prisma/Drizzle)
- Building edge functions (‚Üí Drizzle + edge DB)
- Complex relational data (‚Üí PostgreSQL + Prisma)
- Performance is critical (‚Üí Drizzle or native drivers)
- Want SQL's ACID guarantees (‚Üí PostgreSQL)

### The Verdict

**Mongoose + MongoDB is NOT outdated**, but it's no longer the automatic choice it once was. The "most modern" approach depends on your specific needs:

- **For learning:** Mongoose is still excellent ‚úÖ
- **For production TypeScript apps:** Prisma or Drizzle are more modern
- **For edge/serverless:** Drizzle + edge database
- **For complex apps:** PostgreSQL + Prisma

The approach taught in this notebook (Mongoose + MongoDB with TypeScript) is still widely used, well-supported, and a solid foundation. Once you understand these concepts, switching to other ORMs is straightforward.

---

## Common Issues and Troubleshooting

### Issue 1: Connection Timeout

**Error:**

```
MongooseServerSelectionError: connect ETIMEDOUT
```

**Solutions:**

- Check your internet connection
- Verify MongoDB Atlas IP whitelist (add `0.0.0.0/0` for testing)
- Check firewall settings
- Verify connection string is correct

### Issue 2: Authentication Failed

**Error:**

```
MongooseServerSelectionError: bad auth : authentication failed
```

**Solutions:**

- Check username and password in connection string
- Ensure special characters in password are URL-encoded
- Verify database user has proper permissions

### Issue 3: TypeScript Type Errors

**Error:**

```
Type 'Document<unknown, {}, IUserDocument>' is not assignable to type 'IUserDocument'
```

**Solution:**

```typescript
// Make sure you're extending Document properly
interface IUserDocument extends IUser, Document {}

// And using the correct type in the model
const User = mongoose.model<IUserDocument>("User", userSchema);
```

### Issue 4: Database Name Issues

**Error:**
Data saved but can't find it in MongoDB Atlas

**Solution:**

- Explicitly specify database name in connection string
- Check which database Mongoose actually connected to:

```typescript
console.log(mongoose.connection.name);
```

### Issue 5: Validation Errors

**Error:**

```
ValidationError: User validation failed: email: Path `email` is required.
```

**Solution:**

- Ensure all required fields are provided
- Check field names match schema exactly
- Review validation rules in schema

### Issue 6: Async/Await Type Issues

**Error:**

```
Promise<void> is not assignable to type RequestHandler
```

**Solution:**

```typescript
// Use Promise<void> for Express route handlers
router.get("/users", async (req: Request, res: Response): Promise<void> => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    }
  }
});
```

---

## Best Practices

### 1. Environment Variables with Type Safety

‚úÖ **Do:**

```typescript
// src/types/environment.d.ts
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      MONGO_URI: string;
      PORT: string;
      NODE_ENV: "development" | "production" | "test";
    }
  }
}

// Now TypeScript knows what env vars exist
mongoose.connect(process.env.MONGO_URI); // ‚úÖ Type-safe!
```

‚ùå **Don't:**

```typescript
mongoose.connect("mongodb+srv://user:pass123@cluster.mongodb.net/db"); // Hardcoded!
```

### 2. Error Handling with Type Guards

‚úÖ **Do:**

```typescript
try {
  const user = await User.create(userData);
  res.json(user);
} catch (error) {
  if (error instanceof Error) {
    res.status(400).json({ error: error.message });
  } else {
    res.status(400).json({ error: "Unknown error occurred" });
  }
}
```

‚ùå **Don't:**

```typescript
const user = await User.create(userData); // No error handling!
res.json(user);
```

### 3. Proper Interface Design

‚úÖ **Do:**

```typescript
// Separate concerns
interface IUser {
  name: string;
  email: string;
}

interface IUserDocument extends IUser, Document {}

const User = mongoose.model<IUserDocument>("User", userSchema);
```

‚ùå **Don't:**

```typescript
// Mixing Mongoose and business logic types
interface IUser extends Document {
  name: string;
  email: string;
}
```

### 4. Connection Management

‚úÖ **Do:**

```typescript
// Connect once when server starts
const connectDB = async (): Promise<void> => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("‚úÖ Connected");
  } catch (error) {
    console.error("‚ùå Error:", error);
    process.exit(1);
  }
};

// Graceful shutdown
process.on("SIGINT", async () => {
  await mongoose.connection.close();
  process.exit(0);
});
```

‚ùå **Don't:**

```typescript
// Create new connections for each request
app.get("/users", async (req, res) => {
  await mongoose.connect(MONGO_URI); // ‚ùå Don't do this!
  const users = await User.find();
  res.json(users);
});
```

### 5. Schema Design

‚úÖ **Do:**

```typescript
const userSchema = new Schema<IUserDocument>(
  {
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
      match: [/.+@.+\..+/, "Invalid email"],
    },
  },
  {
    timestamps: true,
  }
);
```

‚ùå **Don't:**

```typescript
const userSchema = new Schema({
  data: Schema.Types.Mixed, // ‚ùå Too loose, no type safety
});
```

### 6. Avoid Returning Passwords

‚úÖ **Do:**

```typescript
const userSchema = new Schema<IUserDocument>({
  password: {
    type: String,
    required: true,
    select: false, // Don't return by default
  },
});

// Or use toJSON transform
userSchema.set("toJSON", {
  transform: (doc, ret) => {
    delete ret.password;
    return ret;
  },
});
```

‚ùå **Don't:**

```typescript
// Returning user with password
const user = await User.findById(id);
res.json(user); // ‚ùå Exposes password!
```

---

## Advanced TypeScript Patterns

### 1. Type-Safe Query Helpers

```typescript
import { Model, Query } from "mongoose";

interface IUserDocument extends IUser, Document {
  // Custom instance methods
  comparePassword(password: string): Promise<boolean>;
}

interface IUserModel extends Model<IUserDocument> {
  // Custom static methods
  findByEmail(email: string): Query<IUserDocument | null, IUserDocument>;
}

// Instance method
userSchema.methods.comparePassword = async function (
  this: IUserDocument,
  password: string
): Promise<boolean> {
  // Implementation
  return true;
};

// Static method
userSchema.statics.findByEmail = function (
  this: IUserModel,
  email: string
): Query<IUserDocument | null, IUserDocument> {
  return this.findOne({ email });
};

const User = mongoose.model<IUserDocument, IUserModel>("User", userSchema);

// Now you can use type-safe methods
const user = await User.findByEmail("alice@example.com");
if (user) {
  const isValid = await user.comparePassword("password123");
}
```

### 2. Virtuals with TypeScript

```typescript
interface IUser {
  firstName: string;
  lastName: string;
}

interface IUserDocument extends IUser, Document {
  fullName: string; // Virtual property
}

const userSchema = new Schema<IUserDocument>({
  firstName: String,
  lastName: String,
});

userSchema.virtual("fullName").get(function (this: IUserDocument) {
  return `${this.firstName} ${this.lastName}`;
});

// Enable virtuals in JSON
userSchema.set("toJSON", { virtuals: true });

const User = mongoose.model<IUserDocument>("User", userSchema);
```

### 3. Middleware with Type Safety

```typescript
// Pre-save middleware
userSchema.pre("save", async function (this: IUserDocument, next) {
  if (this.isModified("password")) {
    // Hash password before saving
    // this.password = await hash(this.password);
  }
  next();
});

// Post-save middleware
userSchema.post("save", function (this: IUserDocument, doc, next) {
  console.log(`User ${doc.email} was saved`);
  next();
});
```

---

## Summary

**Key Takeaways:**

1. **Persistence**: Databases store data permanently, surviving server restarts
2. **MongoDB**: NoSQL database perfect for JavaScript/TypeScript with JSON-like documents
3. **Mongoose**: ODM that provides schemas, validation, and clean API with TypeScript support
4. **Connection**: Use `mongoose.connect(process.env.MONGO_URI)` with type-safe environment variables

**Essential Steps:**

1. Install `mongoose`, `dotenv`, `typescript`, and type definitions
2. Configure TypeScript with `tsconfig.json`
3. Get MongoDB connection string (Atlas or local)
4. Store connection string in `.env` file with type definitions
5. Create connection in `src/config/database.ts`
6. Define TypeScript interfaces and Mongoose schemas
7. Create type-safe models and use them in your application

**TypeScript Benefits:**

- Type safety for environment variables
- Auto-completion for model methods
- Compile-time error catching
- Better refactoring support
- Clear interface contracts

**Remember:**

- Always use environment variables for sensitive data
- Properly type your interfaces and extend Document
- Handle errors with type guards
- Define clear schemas with validation
- Consider modern alternatives like Prisma or Drizzle for new projects
- Use async/await with proper return types for Express routes

---

## Additional Resources

- [Mongoose Documentation](https://mongoosejs.com/docs/guide.html)
- [Mongoose TypeScript Support](https://mongoosejs.com/docs/typescript.html)
- [MongoDB University](https://university.mongodb.com/) - Free courses
- [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) - Free cloud database
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [Prisma Documentation](https://www.prisma.io/docs)
- [Drizzle ORM](https://orm.drizzle.team/)
