# Day 15: Mini-Project Overview - Building a Task API (In-Memory)

## Project Overview

Today's focus is understanding how to **integrate all concepts** from Days 11-14 into a complete, working **REST API** with proper structure, error handling, and middleware.

## What We're Building

A **Task Management API** that allows users to:

- Create tasks
- Read/retrieve tasks
- Update tasks
- Delete tasks
- Filter and paginate tasks
- Handle errors gracefully

## Project Structure

```plaintext
task-api/
├── src/
│   ├── controllers/
│   │   └── taskController.ts
│   ├── routes/
│   │   └── tasks.ts
│   ├── middleware/
│   │   ├── errorHandler.ts
│   │   └── validation.ts
│   ├── models/
│   │   └── Task.ts
│   ├── utils/
│   │   └── asyncHandler.ts
│   ├── app.ts
│   └── index.ts
├── package.json
├── tsconfig.json
└── README.md
```

---

## Key Concepts to Integrate

### 1. Separation of Concerns

- **Routes:** Define endpoints
- **Controllers:** Business logic
- **Middleware:** Cross-cutting concerns
- **Models:** Data structure definitions

### 2. Error Handling Strategy

- Custom error classes
- Centralized error handler
- Proper HTTP status codes
- Meaningful error messages

### 3. Middleware Pipeline

- Body parsing
- CORS
- Logging
- Validation
- Authentication (if needed)

### 4. Data Validation

- Input validation
- Type safety with TypeScript
- Clear error messages for invalid input

### 5. RESTful Design

- Proper HTTP methods
- Resource-based URLs
- Consistent response format
- Pagination support

---

## API Endpoints

The API will expose these endpoints:

| Method | Endpoint         | Description            |
| :----- | :--------------- | :--------------------- |
| GET    | `/api/tasks`     | Get all tasks          |
| GET    | `/api/tasks/:id` | Get task by ID         |
| POST   | `/api/tasks`     | Create new task        |
| PUT    | `/api/tasks/:id` | Update task completely |
| PATCH  | `/api/tasks/:id` | Partially update task  |
| DELETE | `/api/tasks/:id` | Delete task            |

### Query Parameters

```plaintext
GET /api/tasks?page=1&limit=10&completed=false&sort=createdAt&order=desc
```

---

## Core Files Overview

### 1. Models (Type Safety)

Defines the structure of our data:

```typescript
// models/Task.ts
export interface Task {
  id: number;
  title: string;
  description?: string;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

### 2. Controllers (Business Logic)

Handles request processing:

```typescript
// controllers/taskController.ts
export const taskController = {
  getAllTasks: (req, res) => {
    /* ... */
  },
  getTaskById: (req, res) => {
    /* ... */
  },
  createTask: (req, res) => {
    /* ... */
  },
  updateTask: (req, res) => {
    /* ... */
  },
  deleteTask: (req, res) => {
    /* ... */
  },
};
```

### 3. Routes (Endpoint Definition)

Maps URLs to controller actions:

```typescript
// routes/tasks.ts
router.get("/", taskController.getAllTasks);
router.post("/", taskController.createTask);
router.get("/:id", taskController.getTaskById);
router.put("/:id", taskController.updateTask);
router.delete("/:id", taskController.deleteTask);
```

### 4. Middleware (Cross-Cutting Concerns)

Handles logging, validation, error handling:

```typescript
// middleware/errorHandler.ts
app.use(errorHandler); // Must be last

// middleware/validation.ts
router.post("/", validateTaskInput, taskController.createTask);
```

### 5. App Configuration

Ties everything together:

```typescript
// app.ts
const app = express();
app.use(express.json());
app.use(cors());
app.use(loggingMiddleware);
app.use("/api/tasks", tasksRouter);
app.use(errorHandler);
```

---

## Development Workflow

### Step 1: Setup Project

```bash
npm init -y
npm install express cors
npm install -D typescript @types/express @types/node
npx tsc --init
```

### Step 2: Create Models

Define TypeScript interfaces for type safety.

### Step 3: Create In-Memory Data Store

```typescript
let tasks: Task[] = [];
let nextId = 1;
```

### Step 4: Create Controller Methods

Implement business logic for each operation.

### Step 5: Create Routes

Map HTTP requests to controller methods.

### Step 6: Add Middleware

- Error handling
- Request validation
- Logging
- CORS

### Step 7: Test with cURL or Postman

```bash
# Create task
curl -X POST http://localhost:3000/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Node.js"}'

# Get all tasks
curl http://localhost:3000/api/tasks

# Get by ID
curl http://localhost:3000/api/tasks/1

# Update
curl -X PUT http://localhost:3000/api/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"completed":true}'

# Delete
curl -X DELETE http://localhost:3000/api/tasks/1
```

---

## Testing Scenarios

### Successful Operations

- ✅ Create task with valid data
- ✅ Retrieve all tasks
- ✅ Retrieve specific task
- ✅ Update task
- ✅ Delete task

### Error Cases

- ❌ Create task with missing title (validation error)
- ❌ Get non-existent task (404)
- ❌ Update non-existent task (404)
- ❌ Delete non-existent task (404)
- ❌ Invalid request format (400)

---

## Key Lessons from This Project

1. **Separation of Concerns:** Code is organized by responsibility
2. **Type Safety:** TypeScript prevents runtime errors
3. **Error Handling:** All errors are caught and responded to properly
4. **Middleware:** Clean pipeline of request processing
5. **REST Principles:** Proper use of HTTP methods and status codes
6. **Scalability:** Structure makes it easy to add features (authentication, database, etc.)

---

## Next Steps After This Project

With this foundation, you can easily:

- Replace in-memory storage with a real database
- Add JWT authentication
- Add input validation libraries (joi, zod)
- Add logging libraries (winston, pino)
- Deploy to production
- Add testing (Jest, Supertest)

---

## Common Pitfalls to Avoid

1. ❌ Mixing business logic with route handlers
2. ❌ Not validating user input
3. ❌ Forgetting to add error handlers
4. ❌ Using wrong HTTP status codes
5. ❌ Not using middleware for common tasks
6. ❌ Mutating request/response prematurely
7. ❌ Not handling async errors

---

## Summary

This mini-project teaches you:

- How to structure a real Node.js API
- How all the pieces fit together
- Best practices for error handling
- How middleware enables clean code
- RESTful API design principles
