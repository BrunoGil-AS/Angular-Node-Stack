# Day 7: Creational I (Singleton & Factory)

## Singleton

**What is a Singleton?**
A Singleton is a creational design pattern that ensures a class has only one instance while providing a global access point to that instance.

Think of it like a government. A country can have only one official government. Regardless of who needs to contact the government (a citizen, a business, or a foreign entity), they all reach out to the same, single entity. You cannot simply create a "new" government whenever you feel like it; you must work with the existing one.

### Features of the Singleton Design Pattern

**Single Instance:** Ensures only one object of the class exists in the JVM.
**Global Access Point:** Provides a centralized way to access the instance.
**Lazy or Eager Initialization:** An Instance can be created at class load time (eager) or when first needed (lazy).
**Thread Safety:** Can be designed to work correctly in multithreaded environments.
**Resource Management:** Useful for managing shared resources like configurations, logging or database connections.
**Flexibility in Implementation:** Can be implemented using eager initialization, lazy initialization, double-checked locking or an inner static class.

---

### How to Implement It (The Recipe)

Regardless of the programming language, the implementation of a Singleton always follows these three core rules:

1.  **Private Constructor:** You must hide the constructor so that other parts of the code cannot use `new ClassName()` to create new objects.
2.  **Private Static Attribute:** The class must keep a reference to its own single instance inside a private static variable.
3.  **Public Static Method:** The class provides a method (usually named `getInstance`) that acts as the gatekeeper.
    - _Logic:_ If the instance already exists, return it. If it doesn't exist, create it, store it, and then return it.

---

### Example in TypeScript

Here is a classic real-world use case: a **Database Connection**. You usually only want one active pool of connections to your database to save memory and prevent connection limits.

```typescript
class DatabaseConnection {
  // 1. Hold the single instance in a private static variable
  private static instance: DatabaseConnection;

  // 2. Make the constructor private to prevent direct construction calls with the 'new' operator.
  private constructor() {
    // Simulate connection logic
    console.log("Initializing database connection...");
  }

  // 3. The static method that controls access to the singleton instance.
  public static getInstance(): DatabaseConnection {
    // If the instance doesn't exist yet, create it (Lazy Initialization)
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection();
    }

    // Return the existing instance
    return DatabaseConnection.instance;
  }

  public query(sql: string): void {
    console.log(`Executing query: ${sql}`);
  }
}

// --- Usage ---

// const db = new DatabaseConnection(); // Error: Constructor is private.

const db1 = DatabaseConnection.getInstance(); // Logs: "Initializing..."
db1.query("SELECT * FROM users");

const db2 = DatabaseConnection.getInstance(); // Does NOT log "Initializing..."
db2.query("DELETE FROM old_logs");

// Proof that they are the same object
console.log(db1 === db2); // true
```

---

### Pros and Cons

While popular, the Singleton is one of the most controversial patterns. It is often called an "anti-pattern" if used incorrectly.

#### ✅ The Pros

- **Controlled Access:** You have strict control over how and when clients access the instance.
- **Memory Efficiency:** It prevents the overuse of memory by restricting repeated instantiation of resource-heavy objects (like database connections or file managers).
- **Global State:** It creates a shared state that is easy to access across different parts of your application without passing props or arguments down a long chain.

#### ❌ The Cons

- **Violates Single Responsibility Principle:** The class tries to solve two problems at once: doing its actual job (e.g., connecting to a database) _and_ managing its own creation/lifecycle.
- **Hard to Unit Test:** Singletons are notoriously difficult to mock in testing. Because the instance is global and static, tests can affect one another (test pollution). Use Dependency Injection instead if testability is a priority.
- **Hidden Dependencies:** If a class uses a Singleton, that dependency is hidden deep inside the code. It's not obvious from the class definition that it needs the Singleton to function.
- **Concurrency Issues:** In multi-threaded languages (like Java or C++), implementing a thread-safe Singleton requires complex locking mechanisms to prevent two threads from creating an instance simultaneously.

---

## Factory Method Pattern

The Factory Method provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

**Example:**
Think of it like a Logistics Company. Imagine you run a delivery business. Initially, you only have Trucks, so your code is tightly coupled to the Truck class. Later, your business grows, and you need to handle sea shipments using Ships.

If you didn't use a pattern, you'd have to rewrite your entire codebase to add if (type === 'sea') statements everywhere. With the Factory Method, you create a standard way (a method) to "create a vehicle." The "Road Logistics" department overrides this to return a Truck, and the "Sea Logistics" department overrides it to return a Ship. The rest of your code just works with a generic "Vehicle."

### How to Implement It (The Recipe)

To implement this, you need four specific components:

1.  **The Product Interface:** Describes what the objects look like (e.g., `Vehicle`).
2.  **Concrete Products:** The actual objects being created (e.g., `Truck`, `Ship`).
3.  **The Creator Class:** Declares the factory method (e.g., `createTransport()`) that returns a Product object.
4.  **Concrete Creators:** Subclasses that override the factory method to return a specific Concrete Product.

---

### Example in TypeScript

Let's build a cross-platform UI. We need a `Dialog` box that renders a button. However, a Web button looks different than a Windows button.

```typescript
// 1. The Product Interface
interface Button {
  render(): void;
  onClick(f: Function): void;
}

// 2. Concrete Products
class WindowsButton implements Button {
  render() {
    console.log("Rendering a Button in Windows style.");
  }
  onClick(f: Function) {
    console.log("Windows click event bind.");
  }
}

class HTMLButton implements Button {
  render() {
    console.log("Rendering a <button> HTML tag.");
  }
  onClick(f: Function) {
    console.log("Browser click event bind.");
  }
}

// 3. The Creator (Abstract Class)
abstract class Dialog {
  // This is the "Factory Method" - it's abstract here, forcing subclasses to implement it.
  abstract createButton(): Button;

  // The Creator usually contains core business logic that relies on the product
  public renderDialog(): void {
    // Call the factory method to create a product object.
    const button = this.createButton();

    // Now use the product. Note: We don't know if it's Windows or HTML, and we don't care.
    console.log("Dialog: starting render process...");
    button.render();
  }
}

// 4. Concrete Creators
class WindowsDialog extends Dialog {
  createButton(): Button {
    return new WindowsButton();
  }
}

class WebDialog extends Dialog {
  createButton(): Button {
    return new HTMLButton();
  }
}

// --- Usage ---

// The client code works with an instance of a concrete creator,
// albeit through its base interface.
function runApp(os: string) {
  let dialog: Dialog;

  if (os === "Windows") {
    dialog = new WindowsDialog();
  } else {
    dialog = new WebDialog();
  }

  // The client code doesn't care which dialog type it is.
  dialog.renderDialog();
}

runApp("Web");
// Output:
// Dialog: starting render process...
// Rendering a <button> HTML tag.
```

---

### Main Characteristics

- **Decoupling:** The creator (client) code is separated from the concrete classes of the products it creates.
- **Inheritance:** It relies heavily on inheritance (subclassing) to switch between different product implementations.
- **Single Responsibility:** The code that _creates_ the product is in one specific place, separate from the code that _uses_ the product.

---

### Pros and Cons

#### ✅ The Pros

- **Open/Closed Principle:** You can introduce new types of products (e.g., `MacButton`, `LinuxButton`) into the program without breaking existing client code. You just create a new Creator subclass.
- **Single Responsibility Principle:** You move the product creation code into one specific place in the program, making the code easier to support.
- **Flexibility:** It eliminates the need to bind application-specific classes into your code. The code only deals with the product interface.

#### ❌ The Cons

- **Code Complexity:** The code can become complicated quickly because you need to introduce a lot of new subclasses to implement the pattern. In the worst case, you end up with a parallel class hierarchy (for every new `Product`, you need a new `Creator`).
- **Overkill:** It is often overkill for simple projects where a simple helper function or a switch statement would suffice.

## Sources

[`Geeks for Geeks: Singleton Design Pattern`](https://www.geeksforgeeks.org/system-design/singleton-design-pattern/)
[`Geeks for Geeks: Factory method Design Pattern`](https://www.geeksforgeeks.org/system-design/factory-method-for-designing-pattern/)
