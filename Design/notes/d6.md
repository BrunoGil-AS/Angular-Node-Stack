# Day 6: Introduction & Classification

## Design Patterns Overview

Design patterns are reusable solutions to common problems in software design. They provide a template for how to solve a problem in a way that has been proven to be effective. Design patterns can help improve code readability, maintainability, and scalability. they also provide a standardization that can be used across different projects and teams.

**Why to learn design patterns?**

- **Easy to understand**: Design patterns provide a common vocabulary for developers, making it easier to communicate ideas and solutions.
- **Proven solutions**: Design patterns are based on best practices and have been tested in real-world scenarios.
- **Reusable**: Design patterns can be reused across different projects, saving time and effort.
- **Best practices**: Design patterns promote best practices in software design, such as separation of concerns and modularity.

## Classification of Design Patterns

Design patterns are typically classified into three main categories:

- **Creational Patterns**
- **Structural Patterns**
- **Behavioral Patterns**

### Creational Patterns

These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. They help in making a system independent of how its objects are created, composed and represented.

#### Types of Creational Patterns

- **Factory Method**: Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.

  - **Real-World Use Case**: A document editor application that can create different types of documents (e.g., Word, PDF) without specifying the exact class of object that will be created.
  - **Example in TypeScript**:

    ```typescript
    interface Document {
      open(): void;
    }

    class WordDocument implements Document {
      open() {
        console.log("Opening Word Document");
      }
    }

    class PDFDocument implements Document {
      open() {
        console.log("Opening PDF Document");
      }
    }
    abstract class DocumentCreator {
      abstract createDocument(): Document;

      openDocument() {
        const doc = this.createDocument();
        doc.open();
      }
    }
    class WordDocumentCreator extends DocumentCreator {
      createDocument(): Document {
        return new WordDocument();
      }
    }
    class PDFDocumentCreator extends DocumentCreator {
      createDocument(): Document {
        return new PDFDocument();
      }
    }
    // Usage
    const wordCreator = new WordDocumentCreator();
    wordCreator.openDocument(); // Output: Opening Word Document
    const pdfCreator = new PDFDocumentCreator();
    pdfCreator.openDocument(); // Output: Opening PDF Document
    ```

- **Abstract Factory**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes. Just like a Factory of Factories.

  - **Real-World Use Case**: A UI toolkit that can create different themes (e.g., Dark, Light) with a consistent look and feel across all components.
  - **Example in TypeScript**:

    ```typescript
    interface Button {
      render(): void;
    }

    class DarkButton implements Button {
      render() {
        console.log("Rendering Dark Button");
      }
    }

    class LightButton implements Button {
      render() {
        console.log("Rendering Light Button");
      }
    }

    interface GUIFactory {
      createButton(): Button;
    }

    class DarkThemeFactory implements GUIFactory {
      createButton(): Button {
        return new DarkButton();
      }
    }

    class LightThemeFactory implements GUIFactory {
      createButton(): Button {
        return new LightButton();
      }
    }

    // Usage
    function renderUI(factory: GUIFactory) {
      const button = factory.createButton();
      button.render();
    }

    const darkFactory = new DarkThemeFactory();
    renderUI(darkFactory); // Output: Rendering Dark Button

    const lightFactory = new LightThemeFactory();
    renderUI(lightFactory); // Output: Rendering Light Button
    ```

- **Singleton**: Ensures a class has only one instance and provides a global point of access to it.

  - **Real-World Use Case**: A logging service that needs to be accessed globally throughout an application, ensuring that all log messages are written to the same file or output.
  - **Example in TypeScript**:

    ```typescript
    class Logger {
      private static instance: Logger;

      private constructor() {}

      static getInstance(): Logger {
        if (!Logger.instance) {
          Logger.instance = new Logger();
        }
        return Logger.instance;
      }

      log(message: string) {
        console.log(message);
      }
    }

    // Usage
    const logger1 = Logger.getInstance();
    const logger2 = Logger.getInstance();
    console.log(logger1 === logger2); // Output: true
    logger1.log("This is a log message."); // Output: This is a log message.
    ```

- **Builder**: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

  - **Real-World Use Case**: A meal ordering system where customers can customize their meals (e.g., burger, pizza) with different ingredients and sizes.
  - **Example in TypeScript**:

    ```typescript
    class Meal {
      private items: string[] = [];

      addItem(item: string) {
        this.items.push(item);
      }

      showItems() {
        console.log("Meal Items: " + this.items.join(", "));
      }
    }

    interface MealBuilder {
      addMainCourse(): void;
      addSideDish(): void;
      getMeal(): Meal;
    }

    class VegMealBuilder implements MealBuilder {
      private meal: Meal = new Meal();

      addMainCourse() {
        this.meal.addItem("Veg Burger");
      }

      addSideDish() {
        this.meal.addItem("French Fries");
      }

      getMeal(): Meal {
        return this.meal;
      }
    }

    class NonVegMealBuilder implements MealBuilder {
      private meal: Meal = new Meal();

      addMainCourse() {
        this.meal.addItem("Chicken Burger");
      }

      addSideDish() {
        this.meal.addItem("Chicken Wings");
      }

      getMeal(): Meal {
        return this.meal;
      }
    }

    class MealDirector {
      private builder: MealBuilder;

      constructor(builder: MealBuilder) {
        this.builder = builder;
      }

      constructMeal() {
        this.builder.addMainCourse();
        this.builder.addSideDish();
      }
    }

    // Usage
    const vegBuilder = new VegMealBuilder();
    const vegDirector = new MealDirector(vegBuilder);
    vegDirector.constructMeal();
    const vegMeal = vegBuilder.getMeal();
    vegMeal.showItems(); // Output: Meal Items: Veg Burger, French Fries

    const nonVegBuilder = new NonVegMealBuilder();
    const nonVegDirector = new MealDirector(nonVegBuilder);
    nonVegDirector.constructMeal();
    const nonVegMeal = nonVegBuilder.getMeal();
    nonVegMeal.showItems(); // Output: Meal Items: Chicken Burger, Chicken Wings
    ```

- **Prototype**: Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.

  - **Real-World Use Case**: A graphic design application that allows users to create new shapes by cloning existing ones, enabling quick duplication and modification.

    - **Example in TypeScript**:

      ```typescript
      interface Shape {
        clone(): Shape;
        draw(): void;
      }

      class Circle implements Shape {
        radius: number;

        constructor(radius: number) {
          this.radius = radius;
        }

        clone(): Shape {
          return new Circle(this.radius);
        }

        draw() {
          console.log(`Drawing a Circle with radius: ${this.radius}`);
        }
      }

      class Square implements Shape {
        sideLength: number;

        constructor(sideLength: number) {
          this.sideLength = sideLength;
        }

        clone(): Shape {
          return new Square(this.sideLength);
        }

        draw() {
          console.log(`Drawing a Square with side length: ${this.sideLength}`);
        }
      }

      // Usage
      const originalCircle = new Circle(5);
      const clonedCircle = originalCircle.clone();
      clonedCircle.draw(); // Output: Drawing a Circle with radius: 5

      const originalSquare = new Square(10);
      const clonedSquare = originalSquare.clone();
      clonedSquare.draw(); // Output: Drawing a Square with side length: 10
      ```

---

### Structural Patterns

These patterns deal with object composition, creating relationships between objects to form larger structures. Examples include Adapter, Composite, and Decorator.

#### Types of Structural Patterns

- **Adapter**: Allows incompatible interfaces to work together by converting the interface of one class into another expected by the clients.

  - **Real-World Use Case**: Integrating a third-party payment gateway into an e-commerce application that expects a specific payment interface.
  - **Example in TypeScript**:

    ```typescript
    // Target interface
    interface Payment {
      pay(amount: number): void;
    }

    // Adaptee class (third-party payment gateway)
    class ThirdPartyPayment {
      makePayment(amount: number) {
        console.log(
          `Processing payment of $${amount} through Third-Party Gateway`
        );
      }
    }

    // Adapter class
    class PaymentAdapter implements Payment {
      private thirdPartyPayment: ThirdPartyPayment;

      constructor(thirdPartyPayment: ThirdPartyPayment) {
        this.thirdPartyPayment = thirdPartyPayment;
      }

      pay(amount: number): void {
        this.thirdPartyPayment.makePayment(amount);
      }
    }

    // Usage
    const thirdPartyPayment = new ThirdPartyPayment();
    const paymentAdapter = new PaymentAdapter(thirdPartyPayment);
    paymentAdapter.pay(100); // Output: Processing payment of $100 through Third-Party Gateway
    ```

- **Decorator**: Allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class.

  - **Real-World Use Case**: Adding additional features (e.g., border, scroll) to a UI component without modifying its core functionality.
  - **Example in TypeScript**:

    ```typescript
    // Component interface
    interface Text {
      render(): string;
    }

    // Concrete component
    class PlainText implements Text {
      render(): string {
        return "This is plain text.";
      }
    }

    // Decorator base class
    abstract class TextDecorator implements Text {
      protected decoratedText: Text;

      constructor(decoratedText: Text) {
        this.decoratedText = decoratedText;
      }

      abstract render(): string;
    }

    // Concrete decorator - adds border
    class BorderedText extends TextDecorator {
      render(): string {
        return `<border>${this.decoratedText.render()}</border>`;
      }
    }

    // Concrete decorator - adds scroll
    class ScrollableText extends TextDecorator {
      render(): string {
        return `<scroll>${this.decoratedText.render()}</scroll>`;
      }
    }

    // Usage
    const plainText = new PlainText();
    const borderedText = new BorderedText(plainText);
    const scrollableBorderedText = new ScrollableText(borderedText);
    console.log(scrollableBorderedText.render());
    // Output: <scroll><border>This is plain text.</border></scroll>
    ```

- **Fecade**: Provides a simplified interface to a complex subsystem, making it easier to use.

  - **Real-World Use Case**: A home theater system where a single remote control (facade) simplifies the operation of multiple components (TV, DVD player, sound system).
  - **Example in TypeScript**:

    ```typescript
    // Subsystem classes
    class TV {
      on() {
        console.log("TV is ON");
      }
      off() {
        console.log("TV is OFF");
      }
    }

    class DVDPlayer {
      play(movie: string) {
        console.log(`Playing movie: ${movie}`);
      }
      stop() {
        console.log("DVD Player stopped");
      }
    }

    class SoundSystem {
      setVolume(level: number) {
        console.log(`Sound system volume set to ${level}`);
      }
    }

    // Facade class
    class HomeTheaterFacade {
      private tv: TV;
      private dvdPlayer: DVDPlayer;
      private soundSystem: SoundSystem;

      constructor(tv: TV, dvdPlayer: DVDPlayer, soundSystem: SoundSystem) {
        this.tv = tv;
        this.dvdPlayer = dvdPlayer;
        this.soundSystem = soundSystem;
      }

      watchMovie(movie: string) {
        this.tv.on();
        this.soundSystem.setVolume(10);
        this.dvdPlayer.play(movie);
      }

      endMovie() {
        this.dvdPlayer.stop();
        this.tv.off();
      }
    }

    // Usage
    const tv = new TV();
    const dvdPlayer = new DVDPlayer();
    const soundSystem = new SoundSystem();
    const homeTheater = new HomeTheaterFacade(tv, dvdPlayer, soundSystem);

    homeTheater.watchMovie("Inception");
    // Output:
    // TV is ON
    // Sound system volume set to 10
    // Playing movie: Inception

    homeTheater.endMovie();
    // Output:
    // DVD Player stopped
    // TV is OFF
    ```

---

### Behavioral Patterns

These patterns deal with object interaction and responsibility distribution. They help in defining how objects communicate with each other and how responsibilities are assigned.

#### Types of Behavioral Patterns

- **Observer**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

  - **Real-World Use Case**: A news agency system where subscribers (observers) receive updates whenever a new article is published.
  - **Example in TypeScript**:

    ```typescript
    // Subject interface
    interface Subject {
      registerObserver(observer: Observer): void;
      removeObserver(observer: Observer): void;
      notifyObservers(): void;
    }

    // Observer interface
    interface Observer {
      update(news: string): void;
    }

    // Concrete Subject
    class NewsAgency implements Subject {
      private observers: Observer[] = [];
      private news: string = "";

      registerObserver(observer: Observer): void {
        this.observers.push(observer);
      }

      removeObserver(observer: Observer): void {
        this.observers = this.observers.filter((obs) => obs !== observer);
      }

      notifyObservers(): void {
        for (const observer of this.observers) {
          observer.update(this.news);
        }
      }

      publishNews(news: string): void {
        this.news = news;
        this.notifyObservers();
      }
    }

    // Concrete Observer
    class NewsSubscriber implements Observer {
      private name: string;

      constructor(name: string) {
        this.name = name;
      }

      update(news: string): void {
        console.log(`${this.name} received news update: ${news}`);
      }
    }

    // Usage
    const agency = new NewsAgency();
    const subscriber1 = new NewsSubscriber("Subscriber 1");
    const subscriber2 = new NewsSubscriber("Subscriber 2");

    agency.registerObserver(subscriber1);
    agency.registerObserver(subscriber2);

    agency.publishNews("New TypeScript version released!");
    // Output:
    // Subscriber 1 received news update: New TypeScript version released!
    // Subscriber 2 received news update: New TypeScript version released!
    ```

- **Chain of Responsibility**: Allows multiple objects to handle a request without the sender needing to know which object will handle it. The request is passed along a chain of potential handlers until one of them handles it.

  - **Real-World Use Case**: An email filtering system where incoming emails are processed by a series of filters (e.g., spam filter, virus scan) until one of them handles the email.
  - **Example in TypeScript**:

    ```typescript
    // Handler interface
    interface Handler {
      setNext(handler: Handler): Handler;
      handle(request: string): string | null;
    }

    // Abstract handler class
    abstract class AbstractHandler implements Handler {
      private nextHandler: Handler | null = null;

      setNext(handler: Handler): Handler {
        this.nextHandler = handler;
        return handler;
      }

      handle(request: string): string | null {
        if (this.nextHandler) {
          return this.nextHandler.handle(request);
        }
        return null;
      }
    }

    // Concrete handlers
    class SpamFilter extends AbstractHandler {
      handle(request: string): string | null {
        if (request.includes("spam")) {
          return "Email marked as spam.";
        }
        return super.handle(request);
      }
    }

    class VirusScan extends AbstractHandler {
      handle(request: string): string | null {
        if (request.includes("virus")) {
          return "Email contains a virus.";
        }
        return super.handle(request);
      }
    }

    class NormalEmailHandler extends AbstractHandler {
      handle(request: string): string | null {
        return "Email is clean and delivered.";
      }
    }

    // Usage
    const spamFilter = new SpamFilter();
    const virusScan = new VirusScan();
    const normalHandler = new NormalEmailHandler();

    spamFilter.setNext(virusScan).setNext(normalHandler);

    const email1 = "This is a spam email.";
    console.log(spamFilter.handle(email1)); // Output: Email marked as spam.

    const email2 = "This email contains a virus.";
    console.log(spamFilter.handle(email2)); // Output: Email contains a virus.

    const email3 = "Hello, this is a normal email.";
    console.log(spamFilter.handle(email3)); // Output: Email is clean and delivered.
    ```

## Source

[GeeksforGeeks - Design Patterns](https://www.geeksforgeeks.org/system-design/software-design-patterns/)
