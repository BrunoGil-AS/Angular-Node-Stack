# Day 9: Structural Patterns (Adapter, Decorator, Facade)

Structural patterns deal with **how classes and objects are composed** to form larger structures. They help ensure that when parts of a system change, the entire structure doesn't need to change as well. Think of them as architectural blueprints for how components should connect.

---

## Adapter Pattern

The Adapter pattern allows **incompatible interfaces to work together**. It acts as a bridge between two interfaces that couldn't otherwise collaborate, without modifying the existing code.

### Real-World Analogy

Think of a power adapter when traveling internationally. Your laptop charger has a US plug, but the wall outlet in Europe is different. Instead of buying a new charger (modifying your existing code), you use an adapter (a small converter) that makes them compatible.

### Key Features & Concepts

1. **Target Interface:** The interface that the client expects to work with.
2. **Adaptee:** The existing class with an incompatible interface that needs adapting.
3. **Adapter:** The class that implements the Target interface and wraps the Adaptee, translating calls from one interface to the other.
4. **Client:** The code that uses the Target interface.

### When to Use It

- **Legacy Code Integration:** You need to use an old class, but its interface doesn't match what your new system expects.
- **Third-Party Libraries:** Integrating external libraries or APIs that have different interfaces than your application.
- **Interface Standardization:** You want several different classes with different interfaces to be used through a single, unified interface.

### How to Implement It

Let's say you have a modern analytics system that expects data in JSON format, but you have a legacy reporting system that only outputs XML.

```typescript
// The interface our modern system expects (Target)
interface AnalyticsData {
  getJSON(): string;
}

// The legacy system we need to adapt (Adaptee)
class LegacyReportingSystem {
  public getXMLReport(): string {
    return "<report><sales>1000</sales><region>North</region></report>";
  }
}

// The Adapter that bridges the gap
class ReportAdapter implements AnalyticsData {
  private legacySystem: LegacyReportingSystem;

  constructor(legacySystem: LegacyReportingSystem) {
    this.legacySystem = legacySystem;
  }

  getJSON(): string {
    const xml = this.legacySystem.getXMLReport();
    // In reality, you'd parse the XML properly
    // This is simplified for demonstration
    const parsed = { sales: 1000, region: "North" };
    return JSON.stringify(parsed);
  }
}

// Client code - works with the modern interface
function processAnalytics(data: AnalyticsData): void {
  console.log("Processing:", data.getJSON());
}

// Usage
const legacySystem = new LegacyReportingSystem();
const adapter = new ReportAdapter(legacySystem);
processAnalytics(adapter); // Works seamlessly!
```

### Pros and Cons

| Pros                                                                          | Cons                                                                 |
| :---------------------------------------------------------------------------- | :------------------------------------------------------------------- |
| **Single Responsibility:** Separates interface conversion from business logic | **Complexity:** Adds extra classes to the codebase                   |
| **Open/Closed Principle:** Add new adapters without changing existing code    | **Indirection:** Can make code harder to follow if overused          |
| **Reusability:** The same adapter can be reused across the application        | **Performance:** Extra layer of abstraction may have slight overhead |

---

## Decorator Pattern

The Decorator pattern allows you to **attach new behaviors to objects dynamically** by placing them inside wrapper objects. It's an alternative to subclassing for extending functionality.

### Real-World Analogy

Think of ordering coffee. You start with a basic espresso, then you can "decorate" it with milk (latte), add caramel syrup, add whipped cream, etc. Each addition wraps the original coffee and adds new behavior (and cost), without changing the original espresso class.

### Key Features & Concepts

1. **Component Interface:** The common interface for both the original objects and decorators.
2. **Concrete Component:** The class being decorated (the base object).
3. **Base Decorator:** An abstract class that implements the Component interface and holds a reference to a Component.
4. **Concrete Decorators:** Classes that extend the Base Decorator and add specific behaviors.

### When to Use It

- **Runtime Behavior Extension:** You need to add responsibilities to objects at runtime without affecting other objects.
- **Avoiding Class Explosion:** Using inheritance would lead to too many subclasses for every combination of features.
- **Stacking Behaviors:** You want to combine multiple behaviors in various ways (like middleware in Express.js).

### TypeScript/Angular Context

**Angular Decorators** (`@Component`, `@Input`, `@Injectable`) are a specific implementation of metadata decorators. While they don't follow the classic Decorator pattern exactly, they share the core idea: adding behavior/metadata to classes without modifying the class itself.

### How to Implement It

Let's build a notification system where we can add multiple "channels" (Email, SMS, Slack) to a base notification.

```typescript
// Component Interface
interface Notifier {
  send(message: string): void;
}

// Concrete Component - the base notification
class BaseNotifier implements Notifier {
  send(message: string): void {
    console.log(`[App Notification]: ${message}`);
  }
}

// Base Decorator - maintains a reference to a Notifier
abstract class NotifierDecorator implements Notifier {
  protected wrappee: Notifier;

  constructor(notifier: Notifier) {
    this.wrappee = notifier;
  }

  send(message: string): void {
    this.wrappee.send(message);
  }
}

// Concrete Decorator 1: Email
class EmailDecorator extends NotifierDecorator {
  send(message: string): void {
    super.send(message); // Call the wrapped notifier first
    console.log(`[Email]: ${message}`);
  }
}

// Concrete Decorator 2: SMS
class SMSDecorator extends NotifierDecorator {
  send(message: string): void {
    super.send(message);
    console.log(`[SMS]: ${message}`);
  }
}

// Concrete Decorator 3: Slack
class SlackDecorator extends NotifierDecorator {
  send(message: string): void {
    super.send(message);
    console.log(`[Slack]: ${message}`);
  }
}

// Usage - Stack decorators as needed!
let notifier: Notifier = new BaseNotifier();
notifier = new EmailDecorator(notifier);
notifier = new SlackDecorator(notifier);

notifier.send("Server is down!");
// Output:
// [App Notification]: Server is down!
// [Email]: Server is down!
// [Slack]: Server is down!
```

### Pros and Cons

| Pros                                                                     | Cons                                                                           |
| :----------------------------------------------------------------------- | :----------------------------------------------------------------------------- |
| **Flexibility:** Combine behaviors at runtime in any order               | **Complexity:** Many small classes can be hard to manage                       |
| **Single Responsibility:** Each decorator handles one concern            | **Order Dependency:** The order of decorators can affect behavior              |
| **Open/Closed:** Extend behavior without modifying original classes      | **Debugging:** Stack of wrappers can make debugging more challenging           |
| **Avoids Inheritance Hell:** No need for complex inheritance hierarchies | **Identity Issues:** A decorated object is not identical to the original class |

---

## Facade Pattern

The Facade pattern provides a **simplified interface to a complex subsystem**. It doesn't hide the subsystem; it just provides an easier way to access it for common use cases.

### Real-World Analogy

When you call a customer service hotline, you talk to one representative who handles your request internally. They might talk to billing, shipping, and technical departments, but you just interact with one person (the facade). You don't need to know the internal structure of the company.

### Key Features & Concepts

1. **Facade:** A class that provides a simple interface and delegates calls to the appropriate subsystem classes.
2. **Subsystem Classes:** The complex classes that do the actual work. They are unaware of the facade.
3. **Client:** The code that uses the Facade instead of interacting with the subsystem directly.

### When to Use It

- **Simplifying Complex APIs:** When you have a complex library or framework and need a simpler interface for common tasks.
- **Layered Architecture:** To create entry points to each layer of a subsystem.
- **Decoupling:** To reduce dependencies between clients and the complex subsystem.

### Angular/Node Context

An `ApiService` in Angular that wraps `HttpClient` is a perfect example. Instead of configuring headers, handling errors, and parsing responses everywhere in your components, the `ApiService` (Facade) handles all that complexity and exposes simple methods like `getUsers()`, `createUser(data)`.

### How to Implement It

Let's create a Facade for a home theater system with multiple complex components.

```typescript
// Complex Subsystem Classes
class Amplifier {
  on(): void {
    console.log("Amplifier is ON");
  }
  setVolume(level: number): void {
    console.log(`Amplifier volume set to ${level}`);
  }
  off(): void {
    console.log("Amplifier is OFF");
  }
}

class DVDPlayer {
  on(): void {
    console.log("DVD Player is ON");
  }
  play(movie: string): void {
    console.log(`Playing: ${movie}`);
  }
  stop(): void {
    console.log("DVD stopped");
  }
  off(): void {
    console.log("DVD Player is OFF");
  }
}

class Projector {
  on(): void {
    console.log("Projector is ON");
  }
  setWideScreenMode(): void {
    console.log("Projector in widescreen mode");
  }
  off(): void {
    console.log("Projector is OFF");
  }
}

class Lights {
  dim(level: number): void {
    console.log(`Lights dimmed to ${level}%`);
  }
  on(): void {
    console.log("Lights are ON");
  }
}

// The Facade - Simplifies everything!
class HomeTheaterFacade {
  private amp: Amplifier;
  private dvd: DVDPlayer;
  private projector: Projector;
  private lights: Lights;

  constructor(
    amp: Amplifier,
    dvd: DVDPlayer,
    projector: Projector,
    lights: Lights
  ) {
    this.amp = amp;
    this.dvd = dvd;
    this.projector = projector;
    this.lights = lights;
  }

  // One simple method to start movie night
  watchMovie(movie: string): void {
    console.log("\n*** Getting ready to watch a movie... ***\n");
    this.lights.dim(10);
    this.projector.on();
    this.projector.setWideScreenMode();
    this.amp.on();
    this.amp.setVolume(20);
    this.dvd.on();
    this.dvd.play(movie);
  }

  // One simple method to end movie night
  endMovie(): void {
    console.log("\n*** Shutting down movie theater... ***\n");
    this.dvd.stop();
    this.dvd.off();
    this.amp.off();
    this.projector.off();
    this.lights.on();
  }
}

// Client code - So simple!
const amp = new Amplifier();
const dvd = new DVDPlayer();
const projector = new Projector();
const lights = new Lights();

const homeTheater = new HomeTheaterFacade(amp, dvd, projector, lights);

homeTheater.watchMovie("Inception");
// ... enjoy the movie ...
homeTheater.endMovie();
```

### Pros and Cons

| Pros                                                                          | Cons                                                                        |
| :---------------------------------------------------------------------------- | :-------------------------------------------------------------------------- |
| **Simplicity:** Provides a straightforward interface to complex systems       | **God Object Risk:** Facade can become too coupled to all subsystem classes |
| **Decoupling:** Isolates clients from subsystem components                    | **Limited Flexibility:** May not expose all subsystem features              |
| **Easier Maintenance:** Changes in subsystem only require updating the Facade | **Extra Layer:** Adds another abstraction layer                             |
| **Better Testability:** Easier to mock one Facade than multiple subsystems    |                                                                             |

---

## Summary: When to Use Each Pattern

| Pattern       | Use When...                                                  | Key Benefit                   |
| :------------ | :----------------------------------------------------------- | :---------------------------- |
| **Adapter**   | You need to make incompatible interfaces work together       | Interface translation         |
| **Decorator** | You need to add behavior to objects without changing classes | Dynamic behavior extension    |
| **Facade**    | You need to simplify access to a complex subsystem           | Simplified, unified interface |

---

## Quick Reference: Pattern Comparison

```
Adapter:    [Client] → [Adapter] → [Adaptee (different interface)]
            "Makes things compatible"

Decorator:  [Client] → [Decorator] → [Decorator] → [Component]
            "Adds layers of behavior"

Facade:     [Client] → [Facade] → [Subsystem A, B, C, D...]
            "Hides complexity behind a simple door"
```
