# Day 8: Creational II (Builder & Abstract Factory)

## Builder Pattern

This design patter helps you to create instances step by step. It separates the construction process from the objectâ€™s representation, enabling the same method to create different variations of an object. This way avoiding large and complex constructor with a considerable number of parameters, and replacing it by the use of a class builder to set each field value of the class by the call of methods setters.

### Key Features & Concepts

1.  **The Product:** The complex object you are trying to build (e.g., a `Computer`, a `House`, or an `Email`).
2.  **The Builder:** An interface or abstract class that declares the steps needed to build the product (e.g., `setCPU()`, `setRAM()`).
3.  **The Concrete Builder:** The class that actually implements the steps defined in the Builder interface.
4.  **The Director (Optional):** A class that controls the order of the construction steps. It tells the builder _what_ to do, but not _how_ to do it.

### When to Use It

You should consider using the Builder pattern when:

- **"Telescoping Constructor" Problem:** Your class constructor has too many parameters, and many of them are optional (passing `null` or `None` repeatedly is bad practice).
- **Complex Creation:** The object requires a specific sequence of steps to be created validly.
- **Immutability:** You want to create an object that cannot be changed after it is created (immutable), but it has many fields to initialize.

### How to Implement It (Step-by-Step)

Let's build a `UserProfile`. In real applications, user profiles often have a few required fields (like a username) and many optional fields (like address, phone, preferences), making them perfect candidates for this pattern.

#### 1\. The Product

First, we define the class we want to build.

Note that we make the constructor `public`, but in stricter implementations, you might make it `private` so that _only_ the Builder can create instances of this class.

```typescript
// The complex object we want to build
class UserProfile {
  public username: string;
  public email: string;
  public age: number | undefined; // Optional
  public address: string | undefined; // Optional
  public isAdmin: boolean;

  constructor(username: string, email: string) {
    this.username = username;
    this.email = email;
    this.isAdmin = false; // Default value
  }

  public getDetails(): string {
    return `User: ${this.username}, Email: ${this.email}, Admin: ${this.isAdmin}`;
  }
}
```

#### 2\. The Builder

Here is where TypeScript shines.

- **Return Type `this`:** Notice the methods return `this`. This tells TypeScript strictly that we are returning the current instance, allowing us to chain methods safely (Fluent Interface).
- **Type Safety:** TypeScript ensures you can't pass a string where a number is expected (e.g., for `age`).

<!-- end list -->

```typescript
class UserProfileBuilder {
  // We hold a reference to the product we are building
  private user: UserProfile;

  // We require the mandatory fields in the Builder's constructor
  constructor(username: string, email: string) {
    this.user = new UserProfile(username, email);
  }

  // Step 1: Set Age
  public setAge(age: number): this {
    if (age < 0) {
      throw new Error("Age cannot be negative");
    }
    this.user.age = age;
    return this; // Returning 'this' enables chaining
  }

  // Step 2: Set Address
  public setAddress(address: string): this {
    this.user.address = address;
    return this;
  }

  // Step 3: Set Admin Status
  public makeAdmin(): this {
    this.user.isAdmin = true;
    return this;
  }

  // Step 4: Finalize construction
  public build(): UserProfile {
    return this.user;
  }
}
```

#### 3\. Implementation (How to use it)

Now, creating a complex object is clean, readable, and type-safe.

```typescript
// Example 1: A simple user
const simpleUser = new UserProfileBuilder(
  "john_doe",
  "john@example.com"
).build();

console.log(simpleUser.getDetails());
// Output: User: john_doe, Email: john@example.com, Admin: false

// Example 2: A complex admin user with chaining
const adminUser = new UserProfileBuilder("admin_jane", "jane@tech.com")
  .setAge(35)
  .setAddress("123 Silicon Valley Blvd")
  .makeAdmin() // Simple toggle method
  .build();

console.log(adminUser.getDetails());
// Output: User: admin_jane, Email: jane@tech.com, Admin: true
```

### Why is this useful?

Without the Builder pattern, creating that same object might look like this:

```python
# Hard to read: What does the third argument do? Is "None" the GPU or the Storage?
my_pc = Computer("Intel i9", "32GB", "1TB SSD", "NVIDIA RTX 4090")
```

With Builder, the code reads like English: "Set CPU, then set RAM, then build." It dramatically reduces errors caused by swapping parameters.

### Pros and Cons

| Pros                                                                                | Cons                                                                                                 |
| :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- |
| **Readability:** Code is self-explanatory.                                          | **Verbosity:** Requires creating separate Builder classes, which increases the total amount of code. |
| **Flexibility:** You can construct objects step-by-step, deferring execution.       | **Complexity:** For simple objects with few parameters, it is overkill.                              |
| **Immutability:** Helps in building immutable objects without massive constructors. |                                                                                                      |

---

## Abstract Factory Pattern

The Abstract Factory is a creational design pattern that lets you produce families of related or dependent objects without specifying their concrete classes.

Think of it as a "Factory of Factories." While a standard Factory Method creates one type of object, the Abstract Factory creates groups of objects that are meant to work together (e.g., a "Modern" chair and a "Modern" table, vs. a "Victorian" chair and "Victorian" table). It ensures that a client never mixes matching sets of objects.

### Key Features & Concepts

1.  **Abstract Products:** Interfaces for a family of distinct but related products (e.g., `Button`, `Checkbox`).
2.  **Concrete Products:** Specific implementations of these products grouped by variants (e.g., `WindowsButton`, `MacButton`).
3.  **Abstract Factory:** An interface declaring a set of methods for creating each of the abstract products (e.g., `createButton()`, `createCheckbox()`).
4.  **Concrete Factory:** Classes that implement the Abstract Factory interface. Each factory corresponds to a specific variant and creates only product variants that match (e.g., `WindowsFactory` creates `WindowsButton` and `WindowsCheckbox`).
5.  **Client:** The code that calls the factory. It only works with interfaces (Abstract Factory and Abstract Products), so it doesn't care which concrete variant it is using.

### When to Use It

You should consider using the Abstract Factory pattern when:

- **Families of Objects:** Your code needs to work with various families of related products (like UI themes: Light vs. Dark, or OS styles: Windows vs. MacOS).
- **Constraint Enforcement:** You need to ensure that products from one family are not mistakenly mixed with products from another family.
- **Scalability of Variants:** You expect to add new product families in the future (e.g., adding a "Linux" theme) and want to do so without breaking existing code.

### How to Implement It (Step-by-Step)

Let's build a UI Theme system (Light Mode vs. Dark Mode). We need to ensure that if a user selects "Dark Mode," both the Buttons and the Checkboxes are the dark versions.

#### 1\. The Abstract Products

First, define the interfaces for the individual items in the family.

```typescript
// Interface for the first product
interface Button {
  render(): void;
  onClick(f: Function): void;
}

// Interface for the second product
interface Checkbox {
  render(): void;
  toggle(): void;
}
```

#### 2\. The Abstract Factory

Declare the interface that creates the products.

```typescript
interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}
```

#### 3\. Concrete Factories & Products

Now we implement the specific families.

**Family 1: Dark Theme**

```typescript
class DarkButton implements Button {
  render() {
    console.log("Rendering a [Dark Button]");
  }
  onClick(f: Function) {
    console.log("Clicking Dark Button");
    f();
  }
}

class DarkCheckbox implements Checkbox {
  render() {
    console.log("Rendering a [Dark Checkbox]");
  }
  toggle() {
    console.log("Toggling Dark Checkbox");
  }
}

class DarkThemeFactory implements GUIFactory {
  createButton(): Button {
    return new DarkButton();
  }
  createCheckbox(): Checkbox {
    return new DarkCheckbox();
  }
}
```

**Family 2: Light Theme**

```typescript
class LightButton implements Button {
  render() {
    console.log("Rendering a [Light Button]");
  }
  onClick(f: Function) {
    console.log("Clicking Light Button");
    f();
  }
}

class LightCheckbox implements Checkbox {
  render() {
    console.log("Rendering a [Light Checkbox]");
  }
  toggle() {
    console.log("Toggling Light Checkbox");
  }
}

class LightThemeFactory implements GUIFactory {
  createButton(): Button {
    return new LightButton();
  }
  createCheckbox(): Checkbox {
    return new LightCheckbox();
  }
}
```

#### 4\. Implementation (How to use it)

The "Application" (Client) doesn't know if it's using Dark or Light mode. It just asks the factory for a button.

```typescript
// The Client Code
function renderApp(factory: GUIFactory) {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();

  button.render();
  checkbox.render();
}

// Configuration Logic (Where the factory is chosen)
let appFactory: GUIFactory;
const userConfig = "DARK"; // This could come from API or System Settings

if (userConfig === "DARK") {
  appFactory = new DarkThemeFactory();
} else {
  appFactory = new LightThemeFactory();
}

// Run the app
renderApp(appFactory);
// Output:
// Rendering a [Dark Button]
// Rendering a [Dark Checkbox]
```

### Why is this useful?

Without Abstract Factory, you would likely have `if (theme === 'DARK')` statements scattered all over your UI code every time you render a component.

With this pattern, the decision of "which theme to use" happens **once** (at initialization). The rest of your application just says `factory.createButton()` and automatically gets the correct style.

### Pros and Cons

| Pros                                                                                                                         | Cons                                                                                                                                            |
| :--------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| **Consistency:** Guarantees that products from different families are not mixed (e.g., a Dark Button on a Light background). | **Complexity:** Introduces a large number of new interfaces and classes.                                                                        |
| **Single Responsibility Principle:** The product creation code is isolated in one place.                                     | **Rigidity:** Adding a _new kind of product_ (e.g., adding `createSlider`) requires changing the Abstract Factory and _all_ Concrete Factories. |
| **Open/Closed Principle:** You can introduce new variants (e.g., "BlueTheme") without breaking existing client code.         |                                                                                                                                                 |
