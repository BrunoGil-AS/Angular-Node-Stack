# Day 10: Behavioral Patterns (Observer & Strategy)

Behavioral patterns are concerned with **algorithms and the assignment of responsibilities between objects**. They describe not just patterns of objects or classes, but also the patterns of communication between them. These patterns characterize complex control flow that's difficult to follow at runtime.

---

## Observer Pattern

The Observer pattern defines a **one-to-many dependency** between objects. When one object (the Subject) changes state, all its dependents (Observers) are notified and updated automatically.

### Real-World Analogy

Think of a YouTube channel. When you subscribe to a channel, you become an "observer." Whenever the channel (the "subject") uploads a new video, all subscribers get notified. You don't have to keep checking the channel manually‚Äîyou're automatically informed when there's something new.

### Key Features & Concepts

1. **Subject (Publisher):** The object that holds the state and notifies observers when the state changes. It maintains a list of observers.
2. **Observer (Subscriber):** The interface that defines the update method that subjects call to notify observers.
3. **Concrete Subject:** The actual implementation that stores the state and sends notifications.
4. **Concrete Observers:** The actual implementations that react to the subject's notifications.

### When to Use It

- **Event Handling:** When changes in one object need to trigger updates in multiple other objects (like UI components reacting to data changes).
- **Loose Coupling:** When you want the subject and observers to be independent‚Äîthe subject doesn't need to know the concrete classes of its observers.
- **Broadcast Communication:** When an object should notify an unknown number of other objects about its state changes.

### Angular/RxJS Context

The Observer pattern is **foundational to reactive programming**. In Angular:

- **RxJS Observables** are the most common implementation. You subscribe to an Observable, and it notifies you when new values are emitted.
- **Angular Signals** (introduced in Angular 16+) are a more lightweight reactive primitive that also follows observer-like principles for change detection.
- **EventEmitters** in components use this pattern for parent-child communication.

### How to Implement It

Let's build a stock price tracker where multiple displays need to update when the stock price changes.

```typescript
// Observer Interface
interface Observer {
  update(stockSymbol: string, price: number): void;
}

// Subject Interface
interface Subject {
  subscribe(observer: Observer): void;
  unsubscribe(observer: Observer): void;
  notify(): void;
}

// Concrete Subject - Stock Exchange
class StockExchange implements Subject {
  private observers: Observer[] = [];
  private stockSymbol: string = "";
  private price: number = 0;

  subscribe(observer: Observer): void {
    const exists = this.observers.includes(observer);
    if (exists) {
      console.log("Observer already subscribed.");
      return;
    }
    this.observers.push(observer);
    console.log("Observer subscribed successfully.");
  }

  unsubscribe(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index === -1) {
      console.log("Observer not found.");
      return;
    }
    this.observers.splice(index, 1);
    console.log("Observer unsubscribed successfully.");
  }

  notify(): void {
    console.log(`\nNotifying ${this.observers.length} observers...`);
    for (const observer of this.observers) {
      observer.update(this.stockSymbol, this.price);
    }
  }

  // Business logic - when price changes, notify observers
  setStockPrice(symbol: string, price: number): void {
    console.log(`\nüìà Stock Update: ${symbol} is now $${price}`);
    this.stockSymbol = symbol;
    this.price = price;
    this.notify();
  }
}

// Concrete Observer 1 - Mobile App Display
class MobileAppDisplay implements Observer {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  update(stockSymbol: string, price: number): void {
    console.log(
      `üì± [${this.name}] Push notification: ${stockSymbol} = $${price}`
    );
  }
}

// Concrete Observer 2 - Web Dashboard
class WebDashboard implements Observer {
  update(stockSymbol: string, price: number): void {
    console.log(
      `üñ•Ô∏è  [Web Dashboard] Updating chart: ${stockSymbol} at $${price}`
    );
  }
}

// Concrete Observer 3 - Trading Bot
class TradingBot implements Observer {
  private threshold: number;

  constructor(threshold: number) {
    this.threshold = threshold;
  }

  update(stockSymbol: string, price: number): void {
    if (price < this.threshold) {
      console.log(
        `ü§ñ [Trading Bot] BUY SIGNAL! ${stockSymbol} at $${price} is below threshold $${this.threshold}`
      );
    } else {
      console.log(`ü§ñ [Trading Bot] Holding. ${stockSymbol} at $${price}`);
    }
  }
}

// Usage
const stockExchange = new StockExchange();

const mobileApp = new MobileAppDisplay("John's iPhone");
const webDashboard = new WebDashboard();
const tradingBot = new TradingBot(150);

stockExchange.subscribe(mobileApp);
stockExchange.subscribe(webDashboard);
stockExchange.subscribe(tradingBot);

stockExchange.setStockPrice("AAPL", 175);
// All observers get notified

stockExchange.setStockPrice("AAPL", 145);
// Trading bot triggers buy signal!

stockExchange.unsubscribe(mobileApp);
stockExchange.setStockPrice("AAPL", 180);
// Only webDashboard and tradingBot get notified
```

### Pros and Cons

| Pros                                                             | Cons                                                                       |
| :--------------------------------------------------------------- | :------------------------------------------------------------------------- |
| **Loose Coupling:** Subject and observers are loosely coupled    | **Memory Leaks:** Forgetting to unsubscribe can cause memory leaks         |
| **Open/Closed:** Add new observers without modifying the subject | **Unexpected Updates:** Observers might be notified in unexpected order    |
| **Dynamic Relationships:** Subscribe/unsubscribe at runtime      | **Complexity:** Debugging can be tricky with many observers                |
| **Broadcast:** One event can update many listeners automatically | **Performance:** Many observers or frequent updates can impact performance |

---

## Strategy Pattern

The Strategy pattern defines a **family of algorithms**, encapsulates each one, and makes them **interchangeable**. It lets the algorithm vary independently from the clients that use it.

### Real-World Analogy

Think of getting to the airport. You have several "strategies": drive your car, take a taxi, use public transit, or bike. Each strategy gets you to the same destination, but they differ in cost, time, and convenience. You can choose the strategy based on your current needs (budget, urgency, weather) without changing your overall goal.

### Key Features & Concepts

1. **Strategy Interface:** The common interface for all concrete strategies.
2. **Concrete Strategies:** The different implementations of the algorithm (e.g., different payment methods, sorting algorithms, compression types).
3. **Context:** The class that uses a Strategy. It maintains a reference to a Strategy object and delegates the algorithm execution to it.

### When to Use It

- **Multiple Algorithms:** You have different ways of doing the same thing and want to switch between them.
- **Conditional Elimination:** You want to replace large `if-else` or `switch` statements that select an algorithm.
- **Hiding Complexity:** You want to isolate the algorithm's implementation details from the code that uses it.
- **Runtime Flexibility:** You need to change behavior at runtime based on user input or configuration.

### Node.js/Express Context

In Express middleware, you might use different authentication strategies (JWT, OAuth, API Key). The passport.js library is a great example‚Äîit uses the Strategy pattern to support 500+ authentication strategies through a unified interface.

### How to Implement It

Let's build a payment system that supports multiple payment methods.

```typescript
// Strategy Interface
interface PaymentStrategy {
  pay(amount: number): boolean;
  getName(): string;
}

// Concrete Strategy 1: Credit Card
class CreditCardPayment implements PaymentStrategy {
  private cardNumber: string;
  private cvv: string;

  constructor(cardNumber: string, cvv: string) {
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }

  pay(amount: number): boolean {
    // Simulate credit card processing
    const lastFour = this.cardNumber.slice(-4);
    console.log(
      `üí≥ Processing $${amount} via Credit Card ending in ${lastFour}`
    );
    console.log("   Verifying CVV... Approved!");
    return true;
  }

  getName(): string {
    return "Credit Card";
  }
}

// Concrete Strategy 2: PayPal
class PayPalPayment implements PaymentStrategy {
  private email: string;

  constructor(email: string) {
    this.email = email;
  }

  pay(amount: number): boolean {
    console.log(`üÖøÔ∏è  Processing $${amount} via PayPal`);
    console.log(`   Redirecting to PayPal for ${this.email}...`);
    console.log("   Payment confirmed!");
    return true;
  }

  getName(): string {
    return "PayPal";
  }
}

// Concrete Strategy 3: Cryptocurrency
class CryptoPayment implements PaymentStrategy {
  private walletAddress: string;
  private cryptoType: string;

  constructor(walletAddress: string, cryptoType: string = "BTC") {
    this.walletAddress = walletAddress;
    this.cryptoType = cryptoType;
  }

  pay(amount: number): boolean {
    console.log(`‚Çø  Processing $${amount} in ${this.cryptoType}`);
    console.log(`   Sending to wallet: ${this.walletAddress.slice(0, 10)}...`);
    console.log("   Waiting for blockchain confirmation... Success!");
    return true;
  }

  getName(): string {
    return `Crypto (${this.cryptoType})`;
  }
}

// Concrete Strategy 4: Bank Transfer
class BankTransferPayment implements PaymentStrategy {
  private accountNumber: string;
  private routingNumber: string;

  constructor(accountNumber: string, routingNumber: string) {
    this.accountNumber = accountNumber;
    this.routingNumber = routingNumber;
  }

  pay(amount: number): boolean {
    console.log(`üè¶ Processing $${amount} via Bank Transfer`);
    console.log(`   Account: ****${this.accountNumber.slice(-4)}`);
    console.log("   Transfer initiated. Will complete in 1-3 business days.");
    return true;
  }

  getName(): string {
    return "Bank Transfer";
  }
}

// Context - Shopping Cart
class ShoppingCart {
  private items: { name: string; price: number }[] = [];
  private paymentStrategy: PaymentStrategy | null = null;

  addItem(name: string, price: number): void {
    this.items.push({ name, price });
    console.log(`Added "${name}" ($${price}) to cart`);
  }

  getTotal(): number {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }

  // Set the payment strategy at runtime
  setPaymentMethod(strategy: PaymentStrategy): void {
    this.paymentStrategy = strategy;
    console.log(`\nPayment method set to: ${strategy.getName()}`);
  }

  checkout(): boolean {
    if (!this.paymentStrategy) {
      console.log("‚ùå Error: Please select a payment method first!");
      return false;
    }

    const total = this.getTotal();
    console.log(`\nüõí Checking out... Total: $${total}`);
    console.log("-".repeat(40));

    const success = this.paymentStrategy.pay(total);

    if (success) {
      console.log("-".repeat(40));
      console.log("‚úÖ Order placed successfully!\n");
      this.items = []; // Clear cart
    }

    return success;
  }
}

// Usage - Switch strategies at runtime!
const cart = new ShoppingCart();

cart.addItem("TypeScript Book", 45);
cart.addItem("Mechanical Keyboard", 150);
cart.addItem("Monitor Stand", 80);

// User selects Credit Card
cart.setPaymentMethod(new CreditCardPayment("4111111111111234", "123"));
cart.checkout();

// Another purchase with PayPal
cart.addItem("Webcam", 100);
cart.setPaymentMethod(new PayPalPayment("user@email.com"));
cart.checkout();

// Another purchase with Crypto
cart.addItem("NFT Art", 500);
cart.setPaymentMethod(new CryptoPayment("0x1234567890abcdef...", "ETH"));
cart.checkout();
```

### Strategy vs. Conditional Logic

Without Strategy pattern (bad practice):

```typescript
// ‚ùå This gets messy quickly
function processPayment(method: string, amount: number) {
  if (method === "creditCard") {
    // 20 lines of credit card logic
  } else if (method === "paypal") {
    // 20 lines of PayPal logic
  } else if (method === "crypto") {
    // 20 lines of crypto logic
  } else if (method === "bankTransfer") {
    // 20 lines of bank transfer logic
  }
  // Adding a new method means modifying this function!
}
```

With Strategy pattern (clean):

```typescript
// ‚úÖ Clean, extensible, testable
function processPayment(strategy: PaymentStrategy, amount: number) {
  return strategy.pay(amount);
}
// Adding a new method = create a new class, no changes here!
```

### Pros and Cons

| Pros                                                                    | Cons                                                                            |
| :---------------------------------------------------------------------- | :------------------------------------------------------------------------------ |
| **Open/Closed:** Add new strategies without modifying existing code     | **Overhead:** More classes to manage for simple cases                           |
| **Eliminates Conditionals:** Replaces complex switch/if-else statements | **Client Awareness:** Client must know about different strategies to select one |
| **Isolation:** Each algorithm is in its own class, easy to test         | **Increased Objects:** Each strategy is a new object in memory                  |
| **Runtime Flexibility:** Switch algorithms on the fly                   | **Communication Overhead:** Strategy and Context need a way to share data       |

---

## Summary: Behavioral Patterns Comparison

| Pattern      | Intent                                      | Key Mechanism              | Angular/Node Example       |
| :----------- | :------------------------------------------ | :------------------------- | :------------------------- |
| **Observer** | Notify multiple objects about state changes | Subscribe/Notify mechanism | RxJS Observables, Signals  |
| **Strategy** | Make algorithms interchangeable             | Interface + Context        | Passport.js authentication |

---

## Observer vs. Strategy: When to Use Which?

```
Observer:
  - "Something happened, everyone who cares should know"
  - One-to-Many relationship
  - Example: Stock price changed ‚Üí notify all dashboards

Strategy:
  - "I need to do X, but there are different ways to do it"
  - One-to-One relationship (context uses ONE strategy at a time)
  - Example: Process payment ‚Üí use the selected payment method
```

---

## Key Takeaways

1. **Observer** is about **communication**: establishing a subscription model where objects can broadcast events to interested parties without tight coupling.

2. **Strategy** is about **flexibility in algorithms**: defining a family of interchangeable behaviors that can be selected at runtime.

3. Both patterns promote the **Open/Closed Principle**: you can add new observers or strategies without modifying existing code.

4. In modern development:
   - **Observer** ‚Üí RxJS, Event Emitters, Pub/Sub systems, WebSockets
   - **Strategy** ‚Üí Dependency Injection, Plugin architectures, Configuration-based behavior
