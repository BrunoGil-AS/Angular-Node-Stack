# TypeScript Knowledge Assessment

**Based on:** Angular-Node-Stack repository (up to day 15)

Use this canvas to **answer directly**. The goal is to verify and solidify your current TypeScript knowledge.

---

## 1. TypeScript Basics

**1.1** Explain the difference between `type` and `interface`.
Provide one example where `interface` is more appropriate and one where `type` is preferable.

**Answer:**
A type is the label which determines the class of object belongs to. Each object has a type, and is an instance of a class, above the class, is the interface which is a contract of shaping and behavior in case of TS (java is only behavioral contract). It can be represented as a `Matryoshka doll`, Object is the outer shell, what you see, the class is an inner doll which implements another inner layer, the interface. So, Type is more general, describes primitive, union, intersection types, while interface is used to describe the shape of an object or class.

```ts
// Interface example
// person.ts
// Using interface to define the shape of an object
interface Person {
  name: string; // even a interface have typed fields to define the shape
  age: number;
}

import type { Person } from "./person";
// Using interface to type an object
const employee: Person = {
  name: "John Doe",
  age: 30,
};
```

---

**1.2** List at least **five primitive types** in TypeScript and briefly describe when you would use each.

**Answer:**

1. `string`: Used to represent textual data. Example: names, addresses, or any sequence of characters.
2. `number`: Used for numeric values, both integers and floating-point numbers. Example: age, price, or any measurable quantity.
3. `boolean`: Represents a logical value, either `true` or `false`. Example: flags, conditions, or binary states.
4. `null`: Represents the intentional absence of any object value. Example: when a variable is expected to hold an object but currently does not.
5. `undefined`: Indicates that a variable has been declared but not assigned a value. Example: default state of uninitialized variables.

---

**1.3** What happens in the following code? Why?

```ts
let value: unknown = "123"; // this line assigns a string to a variable of type unknown
console.log(value.length); // Error: Object is of type 'unknown'.
```

How would you fix it so it compiles safely?

**Answer:**
changing the type from `unknown` to `string` will fix the error. The `unknown` type is a type-safe counterpart of `any`. When a variable is of type `unknown`, TypeScript does not allow any operations on it until its type is narrowed down to a more specific type.

---

## 2. Functions

**2.1** Write a **generic function** that receives an array of any type and returns its first element.

**Answer:**

```ts
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}
```

---

**2.2** Explain the difference between:

- Optional parameters (`?`)
- Default parameters
- Rest parameters (`...`)

Provide a short example for each.

**Answer:**

- Optional parameters (`?`): These parameters may or may not be provided when the function is called. If not provided, they are `undefined` by default.

  ```ts
  function greet(name?: string) {
    return `Hello, ${name ?? "Guest"}!`; // If name is not provided, it defaults to "Guest"
  }
  ```

- Default parameters: These parameters have a default value that is used if no value is provided when the function is called.

  ```ts
  function greet(name: string = "Guest") {
    return `Hello, ${name}!`;
  }
  ```

- Rest parameters (`...`): These parameters allow a function to accept an indefinite number of arguments as an array.

  ```ts
  function sum(...numbers: number[]) {
    return numbers.reduce((acc, num) => acc + num, 0);
  }

  sum(1, 2, 3); // returns 6
  ```

---

**2.3** What is **function overloading** in TypeScript and how is it implemented?

**Answer:**
Function overloading in TypeScript allows you to define multiple function signatures for a single function implementation. This enables the function to handle different types or numbers of arguments while providing type safety.

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any): any {
  return a + b;
}
```

---

## 3. Interfaces, Objects, and Classes

**3.1** Define an interface `User` with `id`, `name`, and `email`.
Then create a class that implements it and adds a method that returns the name in uppercase.

**Answer:**

```ts
interface User {
  id: number;
  name: string;
  email: string;
}
class UserAccount implements User {
  constructor(public id: number, public name: string, public email: string) {}
  getUpperCaseName(): string {
    return this.name.toUpperCase();
  }
}
```

---

**3.2** Consider the following code:

```ts
class Animal {
  constructor(public name: string) {}
}

class Dog extends Animal {
  bark() {
    return `Woof! I'm ${this.name}`;
  }
}
```

What happens if you write:

```ts
const a = new Animal("X");
a.bark();
```

Explain why.

**Answer:**
You need to define `a` as an instance of `Dog` to call the `bark` method. The `Animal` class does not have a `bark` method, so calling `a.bark()` will result in a compile-time error.

---

## 4. Generics and Utility Types

**4.1** What are **utility types**?
Explain and give an example using `Partial<T>` and `Pick<T, K>` with the `User` interface.

**Answer:**
This types are built-in helpers to modify types without alter the existing implementation.

```ts
interface User {
  id: number;
  name: string;
  email?: string;
}

// Make all properties optional
type UserDraft = Partial<User>;

// Pick only id and name
type UserSummary = Pick<User, "id" | "name">;
```

---

**4.2** Define a generic type `ApiResponse<T>` with the following structure:

- `data: T`
- `status: number`
- `error?: string`

**Answer:**

```ts
interface ApiResponse<T> {
  data: T;
  status: number;
  error?: string;
}
```

---

## 5. Compiler & Configuration

**5.1** What is the purpose of `tsconfig.json`?
Why is it especially important in Angular or Node projects?

**Answer:**
The purpose of `tsconfig.json` is to define the directories root and output at the compilation time, also used to tune some compiler options to fit the project needs. Like how strict the type checking should be, etc.

---

**5.2** Name **two compiler options** related to strict type checking and explain what they do.

**Answer:**

1. `strictNullChecks`: This option makes the compiler check for null and undefined values, preventing accidental use of null or undefined values.
2. `strictFunctionTypes`: This option enables stricter checking of function types, ensuring that functions are only called with compatible argument types.

---

## 6. Type Narrowing & Guards

**6.1** Explain **type narrowing** and show an example using `typeof` or a custom type guard.

**Answer:**
Type narrowing is the process of refining a variable's type within a specific scope based on certain checks or conditions. This allows TypeScript to provide more accurate type information and prevent type errors.

```ts
function isString(value: unknown): boolean {
  return typeof value === "string";
}
```

---

**6.2** Analyze the following code:

```ts
function process(input: string | number) {
  return input + 1;
}
```

What is the problem?
How would you rewrite it so it works correctly and type-safely?

**Answer:**
The problem is that the `+` operator behaves differently for strings and numbers. If `input` is a string, it will concatenate "1" to the string instead of performing numeric addition. To fix this, we can use type narrowing to check the type of `input` before performing the operation.

```ts
function process(input: string | number) {
  if (typeof input === "number") {
    return input + 1; // Numeric addition
  } else {
    return input + "1"; // String concatenation
  }
}
```

---

## 7. Angular & Node Integration

**7.1** In an Angular service, what does `HttpClient.get<MyType>()` return?
Why is typing the response important?

**Answer:**

The response received in this case would be `Observable<MyType>`. I don't understand your stupid question about why typing is important, it's obviously important to have type safety and avoid runtime errors. It's typeScript, not JavaScript, duh.

---

**7.2** In an Express API written in TypeScript, how would you properly type `req.body` when creating a new user?

**Answer:**

You can define an interface for the user data structure and then use it to type `req.body` in your route handler.

```ts
interface NewUser {
  name: string;
  email: string;
  password: string;
}
app.post("/users", (req: Request<{}, {}, NewUser>, res: Response) => {
  const newUser = req.body;
  // Now newUser is properly typed as NewUser
});
```

---

## 8. Mini Practical Challenge

Create a file `utils.ts` that contains:

- A generic function:

```ts
mapObjectValues<T, R>(
  obj: T,
  fn: (value: T[keyof T]) => R
): { [K in keyof T]: R }
```

- Types that guarantee the original object keys are preserved
- An example usage with:

```ts
{
  a: number;
  b: number;
}
```

where the function converts numbers to strings.

**Answer:**

```ts
// utils.ts
export function mapObjectValues<T, R>(
  obj: T,
  fn: (value: T[keyof T]) => R
): { [K in keyof T]: R } {
  const result = {} as { [K in keyof T]: R };
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = fn(obj[key]);
    }
  }
  return result;
}
// Example usage
const numbers = {
  a: 1,
  b: 2,
};
const stringified = mapObjectValues(numbers, (value) => value.toString());
// stringified is of type { a: string; b: string; }
```

---
