# Day 1: The Foundation

**What is TypeScript?** TypeScript is a superset of JavaScript that adds a extra layer for static typing.

**Why Static Typing is added value?** It helps catch errors at compile time rather than runtime, making code more robust and maintainable. This is especially useful in large codebases and teams in enterprise environments.

**Key Features:**

- Static Typing
- Interfaces
- Enums
- Generics
- Access Modifiers
- Utility Types

---

## Setup

### Setting up a TypeScript Project

**Basic Setup:**

1. Install Node.js and npm.
2. type in terminal:

   ```bash
   npm install -g typescript
   ```

   - Check TypeScript installation:

   ```bash
   tsc --version
   ```

3. Create a new project from scratch:

   3.1 move to your project folder:

   ```bash
   mkdir my-ts-project
   cd my-ts-project
   ```

   3.2 Initialize a new project:

   - with npm:
     > This creates a `package.json`, `package-lock.json` files and `node_modules` folder.
     > you can abreviate the command install with `npm i typescript -D` or `npm i typescript --save-dev`

   ```bash
   npm init -y
   npm install typescript --save-dev
   npx tsc --init
   ```

   - with TypeScript:
     > This creates a `tsconfig.json` file.

   ```bash
   npm init -y
   tsc --init
   ```

   > **Note:** the difference between `tsconfig.json` and `package.json` is that the first one is for TypeScript compiler options, while the second one is for managing project dependencies and scripts.
   > **tsc --init vs npx tsc --init:** The first command initializes TypeScript globally, while the second one uses the local version installed in your project.

4. Create a `src` folder and add a `index.ts` file inside it.

   ```bash
   mkdir src
   echo "// Your TypeScript code goes here" > src/index.ts
   ```

5. Compile TypeScript to JavaScript:

   ```bash
   npx tsc
   ```

   > **Bonus:**
   >
   > - if you want to split the compiled files into a separate folder, you can modify the `tsconfig.json` file and uncomment the following lines:
   >
   > ```json
   >     "rootDir": "./src",
   >     "outDir": "./dist",
   > ```
   >
   > - Then run `npx tsc` again, and the compiled JavaScript files will be in the `dist` folder.
   > - modify the file `package.json` to add a script for building the project:
   >
   > ```json
   >     "scripts": {
   >         // delete the existing "test" script
   >         // "nameOfYourScript": "Command to run"
   >         "build": "tsc",
   >         "exec": "node ./dist/index.js"
   >     }
   > ```
   >
   > - Now you can build and run your project with:
   >
   > ```bash
   > npm run build
   > npm run exec
   > ```

### Setting up a TypeScript Project using templates

You can also use pre-made templates to set up a TypeScript project quickly.

1. using vite (for frontend projects):

   ```bash
   npm create vite@latest my-ts-app -- --template vanilla-ts
   cd my-ts-app
   npm install
   npm run dev
   ```

2. using express-generator (for backend projects):

   ```bash
   npx express-generator --typescript my-ts-api
   cd my-ts-api
   npm install
   npm start
   ```

3. using nestjs (for full-stack projects):

   ```bash
   npm i -g @nestjs/cli
   nest new my-nest-app
   cd my-nest-app
   npm run start
   ```

### tsconfig.json

The `tsconfig.json` file is crucial for configuring the TypeScript compiler options for your project. Here are some commonly used options:

- `target`: Specifies the ECMAScript target version (e.g., "ES5", "ES6", "ESNext").
  - ECMAScript is a standard for scripting languages like JavaScript. Different versions (ES5, ES6, ESNext) introduce new features and syntax. Choosing a target version determines which JavaScript features your TypeScript code will be compiled down to, ensuring compatibility with the environments where your code will run.
- `module`: Defines the module system (e.g., "commonjs", "es6", "amd").
- `strict`: Enables all strict type-checking options.
- `rootDir`: Specifies the root directory of your TypeScript source files.
- `outDir`: Specifies the output directory for compiled JavaScript files.

---

## Basic TypeScript Syntax

**How to declare a variable?:**

In the past, we used `var` to declare variables in JavaScript. However, `var` has function scope and can lead to unexpected behaviors due to hoisting. In TypeScript (and modern JavaScript), we use `let` and `const` for variable declarations.

- `let`: Used for variables that can be reassigned. It has block scope.
- `const`: Used for variables that cannot be reassigned. It also has block scope.

```typescript
let mutableVariable: number = 10;
const immutableVariable: number = 20;
mutableVariable = 15; // This is allowed
// immutableVariable = 25; // This will cause an error
// Not initialized variable
let uninitializedVariable: string;
uninitializedVariable = "Hello, TypeScript!";
```

---

## Data Types

TypeScript provides several built-in data types:

| Type                 | Description                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------- |
| `number`             | Represents both integer and floatingâ€‘point numbers.                                             |
| `bigint`             | Represents integers with arbitrary precision.                                                   |
| `string`             | Represents text data.                                                                           |
| `boolean`            | Represents `true`/`false` values.                                                               |
| `array`              | Collection of values of the same type (e.g., `number[]` or `Array<number>`).                    |
| `tuple`              | Array with a fixed number of elements of specified types (e.g., `[string, number]`).            |
| `enum`               | Set of named constants.                                                                         |
| `any`                | Any type; opts out of type checking.                                                            |
| `void`               | Absence of a value; typically used as the return type for functions that don't return anything. |
| `null` / `undefined` | Represent absence of a value.                                                                   |
| `never`              | Values that never occur; used for functions that always throw or never return.                  |
| `symbol`             | Unique identifier.                                                                              |

**Type Annotations:**
TypeScript allows you to specify types for variables, function parameters, and return values using type annotations.

```typescript
let age: number = 25;
// Using bigint
let distanceFromSun: bigint = 14960000000000n;
distanceFromSun = BigInt(14960000000000); // Another way to assign bigint
let name: string = "John Doe";
let isStudent: boolean = true;
// Array of numbers
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];
// Tuple
let person: [string, number] = ["Alice", 30];
// Enum
enum Color {
  Red,
  Green,
  Blue,
}
let favoriteColor: Color = Color.Green;
// Any type
let randomValue: any = 10;
randomValue = "Hello";
randomValue = true;

// Function with type annotations
function greet(person: string): string {
  return `Hello, ${person}!`;
}
// Void function
function logMessage(message: string): void {
  console.log(message);
}
// Null and Undefined
let u: undefined = undefined;
let n: null = null;
// Never
function throwError(message: string): never {
  throw new Error(message);
}
// Symbol
let uniqueId: symbol = Symbol("id");
console.log(uniqueId);
```

### Wrapper Types

TypeScript provides wrapper types for primitive data types, allowing you to use them as objects with additional methods and properties:

- `String`: Wrapper for the `string` primitive type.
- `Number`: Wrapper for the `number` primitive type.
- `Boolean`: Wrapper for the `boolean` primitive type.

```typescript
let str: string = "Hello, TypeScript!";
let strObj: String = new String(str);
console.log(strObj.toUpperCase()); // Outputs: "HELLO, TYPESCRIPT!"
```

### arrays

Arrays in TypeScript can be defined in two primary ways: using square brackets `[]` or the generic `Array<type>` syntax. Both methods allow you to create arrays that hold elements of a specific type.

- multi-type arrays can be created using union types.

  ```typescript
  // Using square brackets
  let numbers: number[] = [1, 2, 3, 4, 5];
  let mixedArray: (number | string)[] = [1, "two", 3, "four"];
  ```

- multidimensional arrays can be created by nesting arrays.

  ```typescript
  // Using generic Array type
  let strings: Array<string> = ["apple", "banana", "cherry"];
  let multiDimensionalArray: number[][] = [
    [1, 2, 3],
    [4, 5, 6],
  ];
  // Accessing array elements
  multiDimensionalArray[0][1]; // Outputs: 2
  ```

- array of tuples

  ```typescript
  let tupleArray: [string, number][] = [
    ["Alice", 30],
    ["Bob", 25],
  ];
  // Accessing tuple elements
  let firstTuple = tupleArray[0];
  let name = firstTuple[0]; // "Alice"
  let age = firstTuple[1]; // 30
  ```

- common array methods

  ```typescript
  let fruits: string[] = ["apple", "banana", "cherry"];
  fruits.push("date"); // Adds "date" to the end of the array
  let firstFruit = fruits.pop(); // Removes and returns the last element ("date")
  let fruitCount = fruits.length; // Gets the number of elements in the array
  ```

- iterating over arrays

  ```typescript
  let colors: string[] = ["red", "green", "blue"];
  for (let color of colors) {
    console.log(color);
  }
  colors.forEach((color) => console.log(color));
  ```

### The "Any" Trap: Difference between any (disable checking) vs unknown (safe dynamic type)

In TypeScript, both `any` and `unknown` are used to represent dynamic types, but they have different implications for type safety and checking.

- `any`: When you declare a variable with the `any` type, you are essentially opting out of type checking for that variable. This means you can assign any value to it, and TypeScript will not perform any type checks or provide any type safety. While this provides flexibility, it can lead to runtime errors if the variable is used inappropriately.

  ```typescript
  let dynamicValue: any;
  dynamicValue = 42; // OK
  dynamicValue = "Hello"; // OK
  dynamicValue = true; // OK

  // No type checking, so this can lead to runtime errors
  console.log(dynamicValue.toFixed(2)); // Runtime error if dynamicValue is not a number
  ```

- `unknown`: The `unknown` type is a safer alternative to `any`. When you declare a variable with the `unknown` type, TypeScript requires you to perform type checks before you can use the variable in a way that assumes a specific type. This helps prevent runtime errors by ensuring that you only use the variable in ways that are safe based on its actual type.

  ```typescript
  let safeValue: unknown;
  safeValue = 42; // OK
  safeValue = "Hello"; // OK
  safeValue = true; // OK
  // Type checking is required before using safeValue
  if (typeof safeValue === "number") {
    console.log(safeValue.toFixed(2)); // OK
  } else {
    console.log("safeValue is not a number");
  }
  ```

---

## Interfaces

Interfaces in TypeScript are used to define the structure of an object. They specify the properties and their types that an object must have. Interfaces help ensure that objects adhere to a specific shape, making your code more predictable and easier to maintain.

```typescript
// Defining an interface
interface Person {
  name: string;
  age: number;
  isStudent?: boolean; // Optional property
}
// Using the interface
let student: Person = {
  name: "Alice",
  age: 20,
  isStudent: true,
};
```

---

## Type Aliases

Type aliases in TypeScript allow you to create a new name for a type. They are similar to interfaces but can be used to define more complex types, such as union types, intersection types, and primitive types.

```typescript
// Defining a type alias
type ID = string | number;
// Using the type alias
let userId: ID;
userId = "abc123"; // OK
userId = 456; // OK
// userId = true; // Error: Type 'boolean' is not assignable to type 'ID'
```

## Final Notes from Day 1 lesson

**Importing Interfaces or other modules from other files:** You can use the keywords `import` and `export` to share interfaces, types, classes, or functions between different files in your TypeScript project. But if you simply want to import types or interfaces without including any runtime code, you can use the `import type` syntax. This is particularly useful for reducing the size of the compiled JavaScript code and avoiding potential circular dependencies.

```typescript
// In User.ts
export interface User {
  id: number;
  name: string;
  email: string;
  role: "admin" | "user";
}
// In index.ts
import type { User } from "./User";
```

**accessing an array element with non-null assertion operand:** It's possible to face this issue when you are accessing to an element from the array to pass it as a parameter in a function, to avoid this you can use the operand `!` to avoid this issue.

```typescript
function greetUser(user: User): string {
  return `Welcome, ${user.name}! You are logged in as a ${user.role}.`;
}
// "!" is used to assert that users[0] is not undefined
let UserToGreet: User = users[0]!;
console.log(greetUser(UserToGreet));
```

---
