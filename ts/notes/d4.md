# Day 4: Generics and Utility Types

## Generics

Generics are a feature that allows you to create reusable and type-safe components (`functions`, `classes`, and `interfaces`) that can work with a variety of data types, rather than a single, fixed one. They act like `placeholders` or `type variables` that are specified when the code is used, ensuring the input and output types remain consistent without sacrificing type checking.

```typescript
function identity`<Type>`(arg: Type): Type {
  return arg;
}
```

Once weâ€™ve written the generic `identity function`, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:

- Explicit declaration:

  ```typescript
  //defining the type of identity Function.
  let output = identity<string>("myString");
  ```

  > Here we explicitly set Type surrounded by the use of `<>` around the keyword `string` rather than `()`.

- Inference declaration:

  ```ts
  let output = identity("myString");
  ```

  > Here we use type argument inference, the compiler set the value of Type for us automatically based on the type of the argument we pass in.

**Working with Generic Type Variables** Some type of variable may be compatible with generics, that's the case of Arrays. In which case you can work the fallowing way:

```ts
function loggingIdentity`<Type>`(arg: Array`<Type>`): Array`<Type>` {
  console.log(arg.length);
  return arg;
}
```

> - You could work with declared array like `Type[]`, but some **classes** are build based in generics.

### Generic clases and Interfaces

A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets `<>` following the name of the class.

- **Generic Class**:

  ```ts
  class Box<T> {
    private content: T;

    constructor(content: T) {
      this.content = content;
    }

    getContent(): T {
      return this.content;
    }
  }

  // Usage with specific types
  const numBox = new Box<number>(100);
  console.log("Number Content:", numBox.getContent()); // Output: Number Content: 100

  const strBox = new Box<string>("Hello, Generics!");
  console.log("String Content:", strBox.getContent()); // Output: String Content: Hello, Generics!
  ```

  > - In this example, the `Box` class works with `number` in one instance and string in another, all while TypeScript ensures type safety.

- **Generic Interfaces**

  ```ts
  interface ApiResponse<T> {
    data: T;
    status: number;
  }

  interface User {
    id: number;
    name: string;
  }

  // Usage with a specific type for the 'data' property
  const userResponse: ApiResponse<User> = {
    data: { id: 1, name: "John Doe" },
    status: 200,
  };

  const errorResponse: ApiResponse<string> = {
    data: "Not Found",
    status: 404,
  };
  ```

  > - Here, the ApiResponse interface can handle User data or a simple string error message, adapting its structure based on the type parameter **T**

### Generic Constrains

The generic constraints are used to restrict the types that a generic type parameter can accept, ensuring that the type adheres to a specific structure or interface.
You define a generic constraint using the `extends` keyword:

```ts
interface Lengthwise {
  length: number;
}

// The generic type T must extend the Lengthwise interface
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // We can now safely access the .length property
  return arg;
}

// This works because strings have a length property
loggingIdentity("hello"); // Output: 5

// This works because arrays have a length property
loggingIdentity([1, 2, 3]); // Output: 3

// This causes a compile-time error because numbers do not have a length property
// loggingIdentity(42);
// the fallowing not
loggingIdentity({ length: 10, value: 42 });
```

- **Constraining a type parameter by another type parameter**

```ts
// T is the type of the object, K is the type of the key
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]; // TypeScript knows 'key' is a valid property of 'obj'
}

const user = { id: 1, name: "Alice" };

// Works fine, becase it is name is a key of user.
const name = getProperty(user, "name");

// Error: "age" is not a property of the user object type
// const age = getProperty(user, "age");
```

**Why to use it?**

- **Type Safety:** Generics ensure that the types passed to a component are used consistently throughout, and type errors are caught at compile time.
- **Code Reusability:** Instead of writing separate functions or interfaces for handling strings, numbers, objects, etc., you can write one generic component that adapts to all.
- **Flexibility and Maintainability**: By creating flexible components, you reduce code duplication, making your codebase easier to maintain and update.

---

## Utility types

Utility types **are built-in, globally available generic types** that facilitate common type transformations, allowing developers to construct new types based on existing ones with less boilerplate code. They are powerful tools for enhancing code flexibility, maintainability, and type safety in scenarios like handling API responses, form data, and configuration objects.

- **Partial`<Type>`:** Makes all properties of a Type optional.
- **Required`<Type>`:** Makes all properties of a Type required.
- **Readonly`<Type>`:** Makes all properties of a Type read-only.
- **Pick`<Type, Keys>`:** Selects a subset of properties (Keys) from a Type.
- **Omit`<Type, Keys>`:** Excludes a subset of properties (Keys) from a Type.
- **Record`<Keys, Type>`:** Creates an object type with specific key and value types.
- **Exclude`<Type, ExcludedUnion>`:** Filters a union type.
- **Extract`<Type, Union>`:** Extracts members from a type that are assignable to a union.
- **NonNullable`<Type>`:** Excludes null and undefined from a type.
- **ReturnType`<Type>`:** Extracts the return type of a function.
- **Parameters`<Type>`:** Extracts function parameter types as a tuple.
- **Awaited`<Type>`:** Unwraps a Promise type.

```ts
interface User {
  id: number;
  name: string;
  email: string;
  password?: string; // Optional property in original interface
}

// Partial: Update only some fields (password is optional here)
type UserUpdate = Partial<User>;
const update: UserUpdate = { name: "John Doe" }; // Valid

// Omit: Create a public user type without sensitive info
type PublicUser = Omit<User, "password">;
const publicProfile: PublicUser = {
  id: 1,
  name: "John Doe",
  email: "john@example.com",
}; // Valid

// Readonly: Prevent modification after creation
type ImmutableUser = Readonly<PublicUser>;
const userConfig: ImmutableUser = {
  id: 2,
  name: "Jane",
  email: "jane@example.com",
};
// userConfig.name = "Sue"; // Error: Cannot assign to 'name' because it is a read-only property.
```

### Best Practices

- **Avoid Duplication:** Use utility types to derive new types from existing ones.
- **Enhance Readability:** Employ these types to make your code's intent clearer.
- **Combine Wisely:** Utility types can be chained, but avoid over-complicating definitions.
- **Leverage Tooling:** Modern IDEs leverage the type information from utility types for better development experience.
