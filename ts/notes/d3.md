# Day 3: Classes, Modifiers, and Inheritance

## Classes

In TypeScript, classes are blueprints for creating objects. They encapsulate data and behavior related to that data. Here's a simple example of a class:

```typescript
class Point {
  x = 0;
  y = 0;
}

const pt = new Point();
// Prints 0, 0
console.log(`${pt.x}, ${pt.y}`);
```

In this example, we define a `Point` class with two properties, `x` and `y`, both initialized to `0`. We then create an instance of the class and log its properties.

If you add a field, you will need mandatory initialization, either in the constructor or via field Initializers:

```typescript
class Person {
  name: string;
  age: number = 0; // Field initializer

  constructor(name: string) {
    this.name = name;
  }

  greet() {
    console.log(
      `Hello, my name is ${this.name} and I am ${this.age} years old.`
    );
  }

  setAge(age: number): void {
    //idiomatic way to set age
    this.age = age;
  }
}
const person = new Person("Alice");
person.greet();
person.setAge(30); // Set age using method
person.greet();
```

In this `Person` class, we have a `name` property that must be initialized in the constructor, and an `age` property with a default value of `0`. The `greet` method logs a greeting message.

### constructors

Constructors are special methods marked with the keyword `constructor` and are used to initialize new instances of a class. They can take parameters to set initial values for the object's properties. Just as we saw in the `Person` class above, the constructor takes a `name` parameter to initialize the `name` property. But also we can have default parameters:

- default parameters in constructors:

  ```typescript
  class Point {
    x: number;
    y: number;

    // Normal signature with defaults
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
    }
  }
  ```

  - Here, the `Point` class constructor has default values for `x` and `y`, so if no arguments are provided, they will default to `0`.

- shorthand for property declaration and initialization:

  ```typescript
  class Point {
    // Shorthand syntax
    constructor(public x: number = 0, public y: number = 0) {}
  }
  ```

  - In this version, we use the shorthand syntax to declare and initialize the `x` and `y` properties directly in the constructor parameters. You can change the visibility modifier (`public`, `private`, `protected`, `readonly`) as needed.

- **Constructor Overloading**: TypeScript does not support multiple constructors directly. However, you can achieve similar functionality using signature overloads, this means defining multiple constructor signatures and implementing a single constructor that handles different cases:

  ```typescript
  class Rectangle {
    width: number;
    height: number;

    constructor();
    constructor(size: number);
    constructor(width: number, height: number);
    constructor(widthOrSize?: number, height?: number) {
      if (widthOrSize !== undefined && height !== undefined) {
        this.width = widthOrSize;
        this.height = height;
      } else if (widthOrSize !== undefined) {
        this.width = widthOrSize;
        this.height = widthOrSize; // Square
      } else {
        this.width = 0;
        this.height = 0;
      }
    }
  }
  ```

  - you can have also methods overloads in a similar way.
  - In this `Rectangle` class, we simulate constructor overloading by defining multiple signatures and implementing a single constructor that handles different cases based on the provided arguments.

---

## Modifiers

Modifiers in TypeScript control the visibility and behavior of class members (properties and methods). The main modifiers are:

| Modifier    | Description                                                                              |
| ----------- | ---------------------------------------------------------------------------------------- |
| `public`    | Members are accessible from anywhere. This is the default modifier if none is specified. |
| `private`   | Members are accessible only within the class itself.                                     |
| `protected` | Members are accessible within the class and its subclasses.                              |
| `readonly`  | Members can be read but not modified after initialization.                               |

Here's an example demonstrating these modifiers:

```typescript
class Animal {
  public name: string; // Accessible from anywhere
  private age: number; // Accessible only within the class
  protected species: string; // Accessible within the class and subclasses
  readonly birthYear: number; // Can be read but not modified

  constructor(name: string, age: number, species: string, birthYear: number) {
    this.name = name;
    this.age = age;
    this.species = species;
    this.birthYear = birthYear;
  }

  public getAge(): number {
    return this.age;
  }
}
const animal = new Animal("Leo", 5, "Lion", 2018);
console.log(animal.name); // Accessible
console.log(animal.getAge()); // Accessible via method
// console.log(animal.age); // Error: Property 'age' is private
// console.log(animal.species); // Error: Property 'species' is protected
// animal.birthYear = 2020; // Error: Cannot assign to 'birthYear' because it is a read-only property
```

In this example, we define an `Animal` class with various modifiers applied to its members. The `name` property is public, the `age` property is private, the `species` property is protected, and the `birthYear` property is readonly.

### getters and setters

Getters and setters are special methods that allow you to control access to class properties. They provide a way to encapsulate the logic for getting and setting property values. Here's an example:

```typescript
class Rectangle {
  private _width: number;
  private _height: number;

  constructor(width: number, height: number) {
    this._width = width;
    this._height = height;
  }

  get width(): number {
    return this._width;
  }

  set width(value: number) {
    if (value <= 0) {
      throw new Error("Width must be positive.");
    }
    this._width = value;
  }

  get height(): number {
    return this._height;
  }

  set height(value: number) {
    if (value <= 0) {
      throw new Error("Height must be positive.");
    }
    this._height = value;
  }

  get area(): number {
    return this._width * this._height;
  }
}
const rect = new Rectangle(10, 20);
console.log(`Area: ${rect.area}`); // Area: 200
rect.width = 15;
console.log(`New Area: ${rect.area}`); // New Area: 300
// rect.height = -5; // Error: Width must be positive.
```

> - In this `Rectangle` class, we use getters and setters to control access to the `_width` and `_height` properties. The `area` getter calculates the area of the rectangle.
>
> - **Set keyword**: The `set` keyword is used to define a setter method for a property. It allows you to specify custom logic that runs when the property is assigned a value.
> - **Get keyword**: The `get` keyword is used to define a getter method for a property. It allows you to specify custom logic that runs when the property is accessed.
> - This methods with the propert keywords allow you to encapsulate the fields and add validation or computed properties. In a less idiomatic way, you could have used normal methods like `getWidth()`, `setWidth(value: number)`, but using getters and setters provides a more natural syntax for property access.
>
> ---

## Parameter Properties

Parameter properties allow you to declare and initialize class properties directly in the constructor parameters. This feature reduces boilerplate code and makes your class definitions more concise. Here's an example:

```typescript
class Car {
  constructor(
    public make: string,
    public model: string,
    private year: number,
    protected mileage: number
  ) {}

  getCarInfo(): string {
    return `${this.year} ${this.make} ${this.model}`;
  }

  getMileage(): number {
    return this.mileage;
  }
}
const myCar = new Car("Toyota", "Camry", 2020, 15000);
console.log(myCar.getCarInfo()); // 2020 Toyota Camry
console.log(`Mileage: ${myCar.getMileage()} miles`); // Mileage: 150
```

- In this `Car` class, we use parameter properties in the constructor to declare and initialize the `make`, `model`, `year`, and `mileage` properties. The visibility modifiers (`public`, `private`, `protected`) determine the accessibility of these properties.

---

## Inheritance

Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit properties and methods from another class. In TypeScript, you can use the `extends` keyword to create a subclass that inherits from a superclass. Here's an example:

```typescript
class Vehicle {
  constructor(public make: string, public model: string) {}

  start() {
    console.log(`Starting the ${this.make} ${this.model}.`);
  }
}
class Car extends Vehicle {
  constructor(make: string, model: string, public numDoors: number) {
    super(make, model); // Call the superclass constructor
  }

  honk() {
    console.log("Beep beep!");
  }
}
const myCar = new Car("Toyota", "Camry", 4);
myCar.start(); // Inherited method
myCar.honk(); // Subclass method
console.log(`My car has ${myCar.numDoors} doors.`);
```

> - In this example, we have a `Vehicle` class that serves as the superclass. The `Car` class extends `Vehicle`, inheriting its properties and methods. The `Car` class also adds its own property, `numDoors`, and a method, `honk`.

- **Super keyword**: The `super` keyword is used to call the constructor of the superclass. In the `Car` class constructor, we use `super(make, model)` to initialize the inherited properties from the `Vehicle` class.

  - You can access superclass methods and properties using `super.methodName()` or `super.propertyName` within subclass methods:

```typescript
class Truck extends Vehicle {
  constructor(make: string, model: string, public payloadCapacity: number) {
    super(make, model);
  }

  start() {
    super.start(); // Call the superclass method
    console.log(`Truck ready to haul ${this.payloadCapacity} tons.`);
  }
}
const myTruck = new Truck("Ford", "F-150", 2);
myTruck.start(); // Calls overridden method
```

- **Method overriding**: You can also override methods from the superclass in the subclass to provide specialized behavior:

```typescript
class Bicycle extends Vehicle {
  constructor(make: string, model: string, public hasBell: boolean) {
    super(make, model);
  }

  // Override the start method
  start() {
    console.log(`Pedaling the ${this.make} ${this.model}.`);
  }
}
const myBike = new Bicycle("Giant", "Escape 3", true);
myBike.start(); // Overridden method
console.log(`Does my bike have a bell? ${myBike.hasBell}`);
```

> - In this `Bicycle` class, we override the `start` method to provide a different implementation specific to bicycles.
> - Inheritance allows for code reuse and the creation of hierarchical relationships between classes, promoting a more organized and modular code structure.

### Types of Inheritance supported

TypeScript supports several types of inheritance:

- **Single Inheritance**: A class can inherit from one superclass. (as shown in the examples above)
- **Multilevel Inheritance**: A class can inherit from a subclass, forming a chain of inheritance.

```typescript
class Animal {
  speak() {
    console.log("Animal speaks");
  }
}
class Dog extends Animal {
  bark() {
    console.log("Dog barks");
  }
}
class Puppy extends Dog {
  weep() {
    console.log("Puppy weeps");
  }
}
const myPuppy = new Puppy();
myPuppy.speak(); // Inherited from Animal
myPuppy.bark(); // Inherited from Dog
myPuppy.weep(); // Own method
```

- **Hierarchical Inheritance**: Multiple classes can inherit from a single superclass.

```typescript
class Shape {
  draw() {
    console.log("Drawing a shape");
  }
}
class Circle extends Shape {
  draw() {
    console.log("Drawing a circle");
  }
}
class Square extends Shape {
  draw() {
    console.log("Drawing a square");
  }
}
const myCircle = new Circle();
const mySquare = new Square();
myCircle.draw(); // Drawing a circle
mySquare.draw(); // Drawing a square
```

- **Multiple Inheritance (via Interfaces)**: While TypeScript does not support multiple inheritance of classes, a class can implement multiple interfaces.

```typescript
interface Flyer {
  fly(): void;
}
interface Swimmer {
  swim(): void;
}
class Duck extends Animal implements Flyer, Swimmer {
  fly() {
    console.log("Duck is flying");
  }
  swim() {
    console.log("Duck is swimming");
  }
}
```

> - In this example, the `Duck` class as an extension of `Animal` class, implements both the `Flyer` and `Swimmer` interfaces, allowing it to have behaviors from both.
> - This allows for a form of multiple inheritance by combining behaviors from different interfaces.
>
> ---

## Abstract Classes and Methods

Abstract classes are classes that cannot be instantiated directly and are meant to be subclassed. They can contain abstract methods, which are methods without an implementation that must be implemented by subclasses. Here's an example:

```typescript
abstract class Shape {
  abstract area(): number; // Abstract method

  describe(): void {
    console.log("This is a shape.");
  }
}
class Circle extends Shape {
  constructor(public radius: number) {
    super();
  }

  area(): number {
    return Math.PI * this.radius * this.radius;
  }
}
const myCircle = new Circle(5);
console.log(`Area of the circle: ${myCircle.area()}`);
myCircle.describe();
```

> - In this example, the `Shape` class is abstract and contains an abstract method `area()`. The `Circle` class extends `Shape` and provides an implementation for the `area()` method.

---

## Summary

- Classes in TypeScript provide a way to create objects with encapsulated data and behavior.
- Constructors are special methods used to initialize new instances of a class, and can include parameters with default values.
- Modifiers (`public`, `private`, `protected`, `readonly`) control the visibility and behavior of class members.
- Getters and setters allow for controlled access to class properties, enabling encapsulation and validation.
- Inheritance allows a class to inherit properties and methods from another class, promoting code reuse and hierarchical relationships.
- The `super` keyword is used to call the constructor and methods of the superclass.
- Method overriding allows subclasses to provide specialized implementations of superclass methods.
- TypeScript supports single inheritance, multilevel inheritance, hierarchical inheritance, and multiple inheritance via interfaces.
