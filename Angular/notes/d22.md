# Day 22: HttpClient & API Consumption

## HttpClient Overview

Angular's `HttpClient` provides typed, RxJS-based HTTP methods: `get`, `post`, `put`, `patch`, `delete`, `request`.
It returns observables which you can `subscribe` to or compose with RxJS.

```typescript
this.http.get<User[]>("/api/users").subscribe((users) => (this.users = users));
```

## Setting Up HttpClient

To use `HttpClient` in your Angular application, you need to import and provide it in your app's configuration.
To address this, you need to set up the provider in your app config file `app.config.ts`:

```typescript
import {
  ApplicationConfig,
  provideBrowserGlobalErrorListeners,
} from "@angular/core";
import { provideRouter } from "@angular/router";

import { routes } from "./app.routes";
import { provideHttpClient } from "@angular/common/http";

export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideRouter(routes),
    provideHttpClient(), //by adding this line we enable HttpClient throughout the app
  ],
};
```

> The line `provideHttpClient()` uses the dependency injection system to make `HttpClient` available for injection in your services and components.

If your app is using NgModule-based bootstrap instead, you can include provideHttpClient in the providers of your app's NgModule:

```ts
@NgModule({
  providers: [provideHttpClient()],
  // ... other application configuration
})
export class AppModule {}
```

> You can add more configuration to `provideHttpClient()` such as
>
> - [WithFetch](https://angular.dev/guide/http/setup#withfetch) to use Fetch API
> - [interceptors](https://angular.dev/guide/http/interceptors)
> - default headers, etc. See the Angular docs for more details.

**After the DI** You can set up the service to consume APIs:

```typescript
@Injectable({ providedIn: "root" })
export class ConfigService {
  private http = inject(HttpClient);
  // This service can now make HTTP requests via `this.http`.
}
```

---

## Common Patterns

- Use services to wrap HTTP calls.
- Centralize base URL via tokens or environment.
- Map and transform responses in services.

```typescript
getUsers() { return this.http.get<ApiResponse<User[]>>(this.apiUrl + '/users').pipe(map(r => r.data)); }
```

---

## HttpParams & Headers

```typescript
const params = new HttpParams().set("page", "1").set("limit", "10");
const headers = new HttpHeaders().set("X-Custom", "value");
this.http.get("/api/tasks", { params, headers, withCredentials: true });
```

---

## Interceptors for Cross-Cutting Concerns

- Add auth token to requests.
- Log requests/responses.
- Retry failed requests.
- Global error handling and transform.

```typescript
@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  intercept(req, next) {
    return next.handle(req).pipe(
      catchError((err) => {
        // map server error to friendly message
        return throwError(() => new Error("Network error"));
      })
    );
  }
}
```

---

## Error Handling Strategies

- Use `catchError` in services for fallback.
- Use global `ErrorInterceptor` to map server errors into `ApiError`.
- Show user-friendly messages in components.

```typescript
this.http
  .get("/api")
  .pipe(
    retry(2),
    catchError((err) => of([]))
  )
  .subscribe();
```

---

## Cancellation

- Use `takeUntil` or `unsubscribe` to cancel pending requests when component is destroyed.

```typescript
private destroy$ = new Subject<void>();
this.http.get('/api').pipe(takeUntil(this.destroy$)).subscribe();
ngOnDestroy(){ this.destroy$.next(); } // ngOnDestroy is a lifecycle hook, which is called when the component is destroyed
```

---

## Typed APIs & DTOs

- Type responses and requests to catch errors at compile time.
- Use DTO interfaces reflecting backend contract.

---

## Caching

- Simple in-memory caching in service.
- Use `shareReplay(1)` to replay responses.

```typescript
getUsersCached(){
  if(!this.users$) this.users$ = this.http.get<User[]>('/api/users').pipe(shareReplay(1));
  return this.users$;
}
```

---

## Best Practices

- Keep HTTP logic in services.
- Use interceptors for cross-cutting features.
- Type all responses.
- Handle errors gracefully and show UX feedback.
- Cancel subscriptions on destroy.
