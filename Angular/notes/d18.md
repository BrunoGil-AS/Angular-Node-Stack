# Day 18: Modern Reactivity - Signals vs. Zone.js (Change Detection)

## What is Change Detection?

**Change Detection** is the process Angular uses to determine when the DOM needs to be updated. When data changes, Angular detects it and re-renders the affected parts of the view.

Traditional Angular used **Zone.js**, but modern Angular (16+) introduced **Signals** as a more efficient alternative.

---

## Zone.js (Traditional Approach)

**Zone.js** intercepts all asynchronous operations and triggers change detection:

```typescript
@Component({
  template: `
    <p>Count: {{ count }}</p>
    <button (click)="increment()">Increment</button>
  `,
})
export class CounterComponent {
  count = 0;

  increment(): void {
    this.count++;
    // Zone.js detects the change and updates the view automatically
  }
}
```

### How Zone.js Works

```plaintext
User Action (click)
        ↓
Zone.js intercepts
        ↓
Callback executed (increment())
        ↓
Angular change detection triggered
        ↓
Template re-evaluated
        ↓
View updated
```

### Zone.js Limitations

1. **Performance:** Triggers change detection for all events, even unrelated ones
2. **Overhead:** Global monkey-patching of async operations
3. **Debugging Complexity:** Hard to track when change detection happens

---

## Signals (Modern Approach - Angular 14+)

**Signals** are a lightweight reactive primitive that make change detection **fine-grained** and **explicit**.

### Creating Signals

```typescript
import { signal, computed } from "@angular/core";

@Component({
  template: `
    <p>Count: {{ count() }}</p>
    <p>Doubled: {{ doubled() }}</p>
    <button (click)="increment()">Increment</button>
  `,
})
export class CounterComponent {
  // Writable signal
  count = signal(0);

  // Computed signal (derived from other signals)
  doubled = computed(() => this.count() * 2);

  increment(): void {
    this.count.set(this.count() + 1);
    // Only components using this signal are re-rendered
  }
}
```

### Key Signal Functions

1. **signal()** - Create a writable signal
2. **computed()** - Create a derived, read-only signal
3. **effect()** - Run side effects when signals change
4. **untracked()** - Read a signal without creating a dependency

### Signal API

```typescript
// Create a signal
const count = signal(0);

// Read the value (must call as function)
console.log(count()); // 0

// Update the value
count.set(1);
count.update((value) => value + 1);

// Readonly signal (returns without parens)
const readonlyCount: Signal<number> = count.asReadonly();
```

---

## Using Signals in Components

### Counter Example

```typescript
import { Component } from "@angular/core";
import { signal } from "@angular/core";

@Component({
  selector: "app-counter",
  standalone: true,
  template: `
    <div class="counter">
      <p>Current: {{ count() }}</p>
      <button (click)="increment()">+</button>
      <button (click)="decrement()">-</button>
      <button (click)="reset()">Reset</button>
    </div>
  `,
  styles: [
    `
      .counter {
        padding: 1rem;
        border: 1px solid #ccc;
      }
    `,
  ],
})
export class CounterComponent {
  count = signal(0);

  increment(): void {
    this.count.update((c) => c + 1);
  }

  decrement(): void {
    this.count.update((c) => c - 1);
  }

  reset(): void {
    this.count.set(0);
  }
}
```

### Computed Signals

Computed signals automatically update when their dependencies change:

```typescript
import { Component } from "@angular/core";
import { signal, computed } from "@angular/core";

@Component({
  selector: "app-todo-stats",
  standalone: true,
  template: `
    <div>
      <h3>Todo Stats</h3>
      <p>Total: {{ tasks().length }}</p>
      <p>Completed: {{ completedCount() }}</p>
      <p>Remaining: {{ remainingCount() }}</p>
      <p>Completion: {{ completionPercent() }}%</p>
    </div>
  `,
})
export class TodoStatsComponent {
  tasks = signal([
    { id: 1, title: "Learn Signals", completed: true },
    { id: 2, title: "Build app", completed: false },
  ]);

  // Derived signals - automatically update when tasks change
  completedCount = computed(
    () => this.tasks().filter((t) => t.completed).length
  );

  remainingCount = computed(
    () => this.tasks().filter((t) => !t.completed).length
  );

  completionPercent = computed(() => {
    const total = this.tasks().length;
    if (total === 0) return 0;
    return Math.round((this.completedCount() / total) * 100);
  });
}
```

### Effects

Run side effects when signals change:

```typescript
import { Component, effect } from "@angular/core";
import { signal } from "@angular/core";

@Component({
  selector: "app-user-settings",
  standalone: true,
  template: `
    <div>
      <p>Theme: {{ theme() }}</p>
      <button (click)="toggleTheme()">Toggle Theme</button>
    </div>
  `,
})
export class UserSettingsComponent {
  theme = signal<"light" | "dark">("light");

  constructor() {
    // Side effect: runs whenever theme changes
    effect(() => {
      const currentTheme = this.theme();
      console.log("Theme changed to:", currentTheme);
      localStorage.setItem("theme", currentTheme);
      document.body.classList.remove("light", "dark");
      document.body.classList.add(currentTheme);
    });
  }

  toggleTheme(): void {
    this.theme.update((t) => (t === "light" ? "dark" : "light"));
  }
}
```

### Untracked

Read a signal without creating a dependency:

```typescript
import { signal, computed, untracked } from "@angular/core";

export class SearchComponent {
  query = signal("");
  results = signal<string[]>([]);

  // Only recomputes when results change, not when query changes
  displayMessage = computed(() => {
    const resultCount = this.results().length;

    // Read query without creating dependency
    const currentQuery = untracked(() => this.query());

    return `Found ${resultCount} results for "${currentQuery}"`;
  });
}
```

---

## Signal vs Zone.js: Performance Comparison

### Zone.js (Traditional)

```typescript
@Component({
  template: `
    <p>Count: {{ count }}</p>
    <button (click)="increment()">Click</button>
  `,
})
export class CounterComponent {
  count = 0;

  increment(): void {
    this.count++;
    // Change detection runs for entire component tree
  }
}
```

**Problem:** Even if only `count` changes, the entire component tree may be checked.

### Signals (Modern)

```typescript
@Component({
  template: `
    <p>Count: {{ count() }}</p>
    <button (click)="increment()">Click</button>
  `,
})
export class CounterComponent {
  count = signal(0);

  increment(): void {
    this.count.update((c) => c + 1);
    // Only templates using count() are updated
  }
}
```

**Benefit:** Only components that actually use the changed signal are re-rendered.

---

## Signals with Services

Services can use signals to manage shared state:

```typescript
// services/counter.service.ts
import { Injectable } from '@angular/core';
import { signal } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CounterService {
  private _count = signal(0);
  count = this._count.asReadonly(); // Public readonly access

  increment(): void {
    this._count.update(c => c + 1);
  }

  reset(): void {
    this._count.set(0);
  }
}

// component.ts
@Component({...})
export class MyComponent {
  constructor(public counter: CounterService) {}

  template: `
    <p>Shared count: {{ counter.count() }}</p>
    <button (click)="counter.increment()">+</button>
  `
}
```

---

## Input Signals (Angular 17.1+)

Pass data to components using signals:

```typescript
import { Component, input } from "@angular/core";

@Component({
  selector: "app-task-item",
  standalone: true,
  template: `
    <div>
      <h3>{{ task().title }}</h3>
      <p>{{ task().description }}</p>
    </div>
  `,
})
export class TaskItemComponent {
  // Signal input - automatically tracks dependency
  task = input({ id: 1, title: "Task", description: "" });
}

// Parent component
@Component({
  template: ` <app-task-item [task]="currentTask()"></app-task-item> `,
})
export class ParentComponent {
  currentTask = signal({ id: 1, title: "Learn Signals" });
}
```

---

## Output Signals (Angular 17.1+)

Emit events using signals:

```typescript
import { Component, output } from "@angular/core";

@Component({
  selector: "app-task-form",
  standalone: true,
  template: `
    <input #titleInput />
    <button (click)="addTask(titleInput.value)">Add</button>
  `,
})
export class TaskFormComponent {
  taskAdded = output<string>();

  addTask(title: string): void {
    this.taskAdded.emit(title);
  }
}

// Parent
@Component({
  template: `
    <app-task-form (taskAdded)="onTaskAdded($event)"></app-task-form>
  `,
})
export class ParentComponent {
  onTaskAdded(title: string): void {
    console.log("Added:", title);
  }
}
```

---

## Migration: RxJS Observable to Signals

### Before (RxJS)

```typescript
import { Component, OnInit } from "@angular/core";
import { Observable } from "rxjs";
import { TaskService } from "./services/task.service";

@Component({
  template: `
    <div *ngIf="tasks$ | async as tasks">
      <div *ngFor="let task of tasks">
        {{ task.title }}
      </div>
    </div>
  `,
})
export class TaskListComponent implements OnInit {
  tasks$: Observable<Task[]>;

  constructor(private taskService: TaskService) {
    this.tasks$ = this.taskService.getTasks();
  }

  ngOnInit(): void {
    // Already subscribed via async pipe
  }
}
```

### After (Signals)

```typescript
import { Component, OnInit, effect } from "@angular/core";
import { signal } from "@angular/core";
import { TaskService } from "./services/task.service";

@Component({
  template: `
    <div>
      @for (task of tasks(); track task.id) {
      <div>{{ task.title }}</div>
      } @empty {
      <p>No tasks</p>
      }
    </div>
  `,
})
export class TaskListComponent implements OnInit {
  tasks = signal<Task[]>([]);

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    this.taskService.getTasks().subscribe((data) => {
      this.tasks.set(data);
    });
  }
}
```

---

## Benefits of Signals

✅ **Better Performance:** Fine-grained reactivity  
✅ **Cleaner Code:** No async pipe needed in templates  
✅ **Type-Safe:** Fully typed at compile time  
✅ **Explicit:** Clear what depends on what  
✅ **Smaller Bundles:** Less Zone.js overhead needed

---

## Zone.js Not Completely Removed

You can still use Zone.js with Signals, or disable it for smaller bundles:

```typescript
// In main.ts, with zoneless approach
import { bootstrapApplication } from "@angular/platform-browser";
import { AppComponent } from "./app/app.component";

bootstrapApplication(AppComponent, {
  ngZone: "zone.js", // or 'noop' for zoneless
});
```

---

## Summary

- **Change Detection** updates the DOM when data changes
- **Zone.js** is the traditional approach (still supported)
- **Signals** are modern, more efficient reactive primitives
- **Computed signals** automatically derive values
- **Effects** run side effects when signals change
- **Input signals** and **output signals** simplify component communication
- **Signals require calling as functions:** `count()` not `count`
- Migrate gradually: Both approaches can coexist
