# Day 19: Angular Component Communication - Inputs, Outputs, and Services

## Component Hierarchy

In Angular, components form a tree structure where data flows down and events flow up:

```plaintext
AppComponent (Root)
    ├── HeaderComponent
    │   └── NavbarComponent
    ├── MainComponent
    │   ├── SidebarComponent
    │   └── ContentComponent
    │       ├── TaskListComponent
    │       │   └── TaskItemComponent
    │       └── TaskFormComponent
    └── FooterComponent
```

---

## 1. Parent to Child: @Input

Pass data from parent to child using **@Input** decorator:

### Child Component

```typescript
import { Component, Input } from "@angular/core";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-item",
  standalone: true,
  template: `
    <div class="task-item" [class.completed]="task.completed">
      <input type="checkbox" [checked]="task.completed" />
      <span>{{ task.title }}</span>
      <small>{{ task.createdAt | date : "short" }}</small>
    </div>
  `,
  styles: [
    `
      .task-item {
        padding: 1rem;
        border: 1px solid #ddd;
      }
      .completed {
        opacity: 0.5;
        text-decoration: line-through;
      }
    `,
  ],
})
export class TaskItemComponent {
  @Input() task!: Task;
}
```

### Parent Component

```typescript
import { Component } from "@angular/core";
import { CommonModule } from "@angular/common";
import { TaskItemComponent } from "./task-item/task-item.component";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-list",
  standalone: true,
  imports: [CommonModule, TaskItemComponent],
  template: `
    <div>
      @for (task of tasks; track task.id) {
      <app-task-item [task]="task"></app-task-item>
      }
    </div>
  `,
})
export class TaskListComponent {
  tasks: Task[] = [
    { id: 1, title: "Learn Angular", completed: false, createdAt: new Date() },
    { id: 2, title: "Build app", completed: true, createdAt: new Date() },
  ];
}
```

### Advanced @Input Features

#### Optional Input with Default

```typescript
@Component({...})
export class MyComponent {
  @Input() title = 'Default Title';
  @Input() count: number = 0;
}

```

#### Required Input

```typescript
import { Input } from '@angular/core';

@Component({...})
export class MyComponent {
  @Input({ required: true }) title!: string;
}
```

#### Input with Transform

```typescript
import { Input, booleanAttribute, numberAttribute } from '@angular/core';

@Component({...})
export class MyComponent {
  // Converts string '123' to number 123
  @Input({ transform: numberAttribute }) count = 0;

  // Converts various truthy strings to boolean
  @Input({ transform: booleanAttribute }) isActive = false;
}
```

#### Respond to Input Changes

```typescript
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({...})
export class MyComponent implements OnChanges {
  @Input() title = '';

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['title']) {
      console.log('Title changed to:', changes['title'].currentValue);
    }
  }
}

```

### ✨ Modern Approach: Signal Inputs

Angular now supports **Signal Inputs**, which provide a reactive way to receive data. They are more type-safe and don't require `ngOnChanges`.

```typescript
import { Component, input, effect, numberAttribute } from '@angular/core';

@Component({...})
export class ModernComponent {
  // 1. Optional input with default value (type inferred as number)
  count = input(0);

  // 2. Required input (type must be specified)
  explicitType = input<number>();// you can add a default value like this: input<number>(0);



  // 2. Required input (type must be specified)
  title = input.required<string>();

  // 3. Input with Transform
  // Automatically handles type conversion (e.g., '10' -> 10)
  width = input(100, { transform: numberAttribute });
  // you can define a custom transform function
  trans = input(100, { transform: toBoolean });



  // 4. Input with Alias
  userName = input('', { alias: 'user-name' });

  constructor() {
    // React to changes using effects (replaces ngOnChanges)
    effect(() => {
      console.log(`Title changed to: ${this.title()}`);
      console.log(`New count is: ${this.count()}`);
    });
  }

  // Usage in template: {{ title() }} - note the parenthesis
}

// custom transform function
function toBoolean(value: string): boolean {
  return value.toLowerCase() === 'true';
}


```

---

## 2. The Output, from child to parent

Emit events from child to parent:

### Child Component

```typescript
import { Component, Output, EventEmitter } from "@angular/core";

@Component({
  selector: "app-task-form",
  standalone: true,
  template: `
    <form (ngSubmit)="onSubmit()">
      <input
        type="text"
        [(ngModel)]="title"
        name="title"
        placeholder="Enter task"
      />
      <button type="submit">Add Task</button>
    </form>
  `,
})
export class TaskFormComponent {
  title = "";

  // Define an output event
  @Output() taskAdded = new EventEmitter<string>();

  onSubmit(): void {
    if (this.title.trim()) {
      this.taskAdded.emit(this.title);
      this.title = "";
    }
  }
}
```

### Parent Component

```typescript
import { Component } from "@angular/core";
import { CommonModule } from "@angular/common";
import { TaskFormComponent } from "./task-form/task-form.component";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-manager",
  standalone: true,
  imports: [CommonModule, TaskFormComponent],
  template: `
       
    <div>
            <app-task-form (taskAdded)="onTaskAdded($event)"></app-task-form>

           
      <ul>
                @for (task of tasks; track task.id) {        
        <li>{{ task.title }}</li>
                }      
      </ul>
         
    </div>
     
  `,
})
export class TaskManagerComponent {
  tasks: Task[] = [];
  private nextId = 1;

  onTaskAdded(title: string): void {
    const newTask: Task = {
      id: this.nextId++,
      title,
      completed: false,
      createdAt: new Date(),
    };
    this.tasks.push(newTask);
  }
}
```

### ✨ Modern Approach: Signal Outputs

The `output()` function creates an output that doesn't use RxJS `EventEmitter` internally, but maintains the same API for emitting.

```typescript
import { Component, output } from '@angular/core';

@Component({...})
export class ModernFormComponent {
  // Define output (type inferred or explicit)
  taskAdded = output<string>();

  // Output with alias
  onClose = output<void>({ alias: 'closeEvent' });

  submit(value: string) {
    // Usage is identical to EventEmitter
    this.taskAdded.emit(value);
  }
}
// Note: Parent component syntax (HTML) remains exactly the same: (taskAdded)="..."

```

### Two-Way Communication with @Input and @Output

```typescript
// Child component
@Component({...})
export class ToggleComponent {
  @Input() isActive = false;
  @Output() isActiveChange = new EventEmitter<boolean>();

  toggle(): void {
    this.isAtive = !this.isActive;
    this.isActiveChange.emit(this.isActive);
  }
}

// Parent component - using two-way binding
@Component({
  template: `
    <!-- Traditional way -->
    <app-toggle [isActive]="isOpen" (isActiveChange)="isOpen = $event"></app-toggle>

    <!-- Or with banana-in-a-box syntax -->
    <app-toggle [(isActive)]="isOpen"></app-toggle>
  `
})
export class ParentComponent {
  isOpen = false;
}

```

### ✨ Modern Approach: Model Inputs (Signals)

`model()` creates a writable signal that supports two-way binding automatically. It replaces the `@Input() value` + `@Output() valueChange` pattern.

```typescript
import { Component, model } from '@angular/core';

@Component({...})
export class ModernToggleComponent {
  // Creates a two-way bindable signal
  isActive = model(false); // Default value false

  // Required model
  expanded = model.required<boolean>();

  toggle(): void {
    // We update it just like a writable signal
    // This automatically notifies the parent!
    this.isActive.update(v => !v);
  }
}

// Parent Template (remains the same):
// <app-modern-toggle [(isActive)]="isOpen" />

```

---

## 3. Sibling Communication: Shared Service

When siblings need to communicate, use a shared service:

### Service ([Day 20](/Angular/notes/d20.md) required)

```typescript
import { Injectable } from "@angular/core";
import { BehaviorSubject, Observable } from "rxjs";
import { Task } from "../models/task.model";

@Injectable({ providedIn: "root" })
export class TaskService {
  private taskSubject = new BehaviorSubject<Task[]>([]);
  tasks$ = this.taskSubject.asObservable();

  private selectedTaskSubject = new BehaviorSubject<Task | null>(null);
  selectedTask$ = this.selectedTaskSubject.asObservable();

  getTasks(): Observable<Task[]> {
    return this.tasks$;
  }

  setTasks(tasks: Task[]): void {
    this.taskSubject.next(tasks);
  }

  selectTask(task: Task): void {
    this.selectedTaskSubject.next(task);
  }

  getSelectedTask(): Observable<Task | null> {
    return this.selectedTask$;
  }
}
```

### ✨ Modern Approach: Service with Writable Signals

Instead of `BehaviorSubject`, you can use `signal` inside services for simpler state management.

```typescript
import { Injectable, signal, computed } from "@angular/core";
import { Task } from "../models/task.model";

@Injectable({ providedIn: "root" })
export class ModernTaskService {
  // 1. State as Writable Signals
  private tasksSignal = signal<Task[]>([]);
  private selectedTaskSignal = signal<Task | null>(null);

  // 2. Expose as ReadOnly signals (optional but good practice)
  tasks = this.tasksSignal.asReadonly();
  selectedTask = this.selectedTaskSignal.asReadonly();

  // 3. Computed signals (Derived state)
  completedTaskCount = computed(
    () => this.tasksSignal().filter((t) => t.completed).length
  );

  setTasks(tasks: Task[]): void {
    this.tasksSignal.set(tasks);
  }

  addTask(task: Task): void {
    this.tasksSignal.update((current) => [...current, task]);
  }

  selectTask(task: Task): void {
    this.selectedTaskSignal.set(task);
  }
}
```

### First Child Component

```typescript
@Component({
  selector: "app-task-list",
  template: `
    <ul>
            @for (task of tasks(); track task.id) {      
      <li (click)="selectTask(task)">{{ task.title }}</li>
            }    
    </ul>
  `,
})
export class TaskListComponent {
  tasks = signal<Task[]>([]);

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    // Load tasks and update signal
    this.taskService.getTasks().subscribe((tasks) => {
      this.tasks.set(tasks);
    });
  }

  selectTask(task: Task): void {
    this.taskService.selectTask(task);
  }
}
```

### Second Child Component

```typescript
@Component({
  selector: "app-task-detail",
  template: `
    @if (selectedTask(); as task) {
    <div>
      <h3>{{ task.title }}</h3>
      <p>{{ task.description }}</p>
    </div>
    } @else {
    <p>Select a task to view details</p>
    }
  `,
})
export class TaskDetailComponent {
  selectedTask = signal<Task | null>(null);

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    this.taskService.getSelectedTask().subscribe((task) => {
      this.selectedTask.set(task);
    });
  }
}
```

---

## 4. Template Reference Variables

Reference child components directly in the template:

```typescript
// Child component
@Component({
  selector: "app-counter",
  standalone: true,
  template: `
       
    <p>Count: {{ count }}</p>
        <button (click)="increment()">+</button>
     
  `,
})
export class CounterComponent {
  count = 0;

  increment(): void {
    this.count++;
  }

  reset(): void {
    this.count = 0;
  }
}

// Parent component
@Component({
  selector: "app-parent",
  standalone: true,
  imports: [CounterComponent],
  template: `
       
    <div>
            <app-counter #counter></app-counter>      
      <button (click)="resetCounter()">Reset from Parent</button>    
    </div>
     
  `,
})
export class ParentComponent {
  @ViewChild("counter") counterComponent!: CounterComponent;

  resetCounter(): void {
    this.counterComponent.reset();
  }
}
```

### ✨ Modern Approach: Signal Queries (viewChild)

Signal queries replace `@ViewChild`, `@ViewChildren`, `@ContentChild` decorators. They provide the results as a Signal.

```typescript
import { Component, viewChild, ElementRef } from '@angular/core';

@Component({...})
export class ModernParentComponent {
  // viewChild returns a Signal<CounterComponent | undefined>
  counterComponent = viewChild<CounterComponent>('counter');

  // Required viewChild (throws if not found)
  header = viewChild.required<ElementRef>('header');

  resetCounter(): void {
    // Access the value with parenthesis
    this.counterComponent()?.reset();
  }
}

```

---

## 5. Content Projection: ng-content

Allow parents to inject content into children:

### Child Component

```typescript
@Component({
  selector: "app-card",
  template: `
    <div class="card">
           
      <div class="card-header">
        <ng-content select="[cardHeader]"></ng-content>
      </div>
      <div class="card-body">
        <ng-content></ng-content>
      </div>
      <div class="card-footer">
        <ng-content select="[cardFooter]"></ng-content>
      </div>
    </div>
  `,
  styles: [
    `
      .card {
        border: 1px solid #ddd;
        border-radius: 4px;
      }
    `,
  ],
})
export class CardComponent {}
```

### Parent Component

```typescript
@Component({
  template: `
    <app-card>
      <h2 cardHeader>Task Details</h2>

      <p>This is the main content</p>

      <button cardFooter>Close</button>
    </app-card>
  `,
})
export class ParentComponent {}
```

---

## 6. Dependency Injection in Services

Services can inject other services:

```typescript
// Logger service
@Injectable({ providedIn: 'root' })
export class LoggerService {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }
}

// Task service uses logger
@Injectable({ providedIn: 'root' })
export class TaskService {
  constructor(private logger: LoggerService) {}

  createTask(title: string): void {
    this.logger.log(`Creating task: ${title}`);
    // Create task...
  }
}

// Component uses task service
@Component({...})
export class TaskFormComponent {
  constructor(private taskService: TaskService) {}
  // TaskService automatically gets LoggerService injected
}

```

### ✨ Modern Approach: inject()

You can now use the `inject()` function instead of the constructor for cleaner Dependency Injection.

```typescript
import { Component, inject } from '@angular/core';

@Component({...})
export class TaskFormComponent {
  // No constructor needed
  private taskService = inject(TaskService);

  // Works in services too
}

```

---

## Communication Patterns Summary

| Pattern               | When to Use                              | Complexity  | Modern Signal API             |
| --------------------- | ---------------------------------------- | ----------- | ----------------------------- |
| **@Input**            | Pass data down to child                  | Low         | `input()`, `input.required()` |
| **@Output**           | Send events up to parent                 | Low         | `output()`                    |
| **Two-Way Binding**   | Sync data parent <> child                | Medium      | `model()`                     |
| **Shared Service**    | Communicate between siblings or complex  | Medium      | Service + `signal()`          |
| **@ViewChild**        | Access child component instance          | Medium      | `viewChild()`                 |
| **ng-content**        | Reusable templates with slots            | Medium      | `contentChild()`              |
| **State Management**  | Large apps with complex state            | High        | NgRx Signal Store             |

---

## Best Practices

1. ✅ Keep components focused and single-responsibility
2. ✅ Use @Input/@Output (or `input()`/`output()`) for parent-child relationships
3. ✅ Use services for shared state across components
4. ✅ Avoid tight coupling between components
5. ✅ Use signals in services for reactive state management (simpler than BehaviorSubjects)
6. ✅ Document inputs and outputs clearly
7. ❌ Avoid accessing sibling components directly
8. ❌ Don't put too much logic in components

---

## Summary

- **Inputs:** `input()` (Signal) or `@Input` (Decorator) to receive data.
- **Outputs:** `output()` (Function) or `@Output` (Decorator) to emit events.
- **Model:** `model()` for easy two-way binding with signals.
- **Services:** Share state using `WritableSignal` instead of `BehaviorSubject`.
- **Queries:** `viewChild()` and `contentChild()` for accessing DOM/Components.
- **ng-content:** Project content from parent to child.
- **RxJS:** Still useful for complex async event streams (debounce, switchMap), but Signals handle sync state better.

```

```
