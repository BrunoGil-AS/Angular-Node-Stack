# Day 19: Angular Component Communication - Inputs, Outputs, and Services

## Component Hierarchy

In Angular, components form a tree structure where data flows down and events flow up:

```
AppComponent (Root)
    ├── HeaderComponent
    │   └── NavbarComponent
    ├── MainComponent
    │   ├── SidebarComponent
    │   └── ContentComponent
    │       ├── TaskListComponent
    │       │   └── TaskItemComponent
    │       └── TaskFormComponent
    └── FooterComponent
```

---

## 1. Parent to Child: @Input

Pass data from parent to child using **@Input** decorator:

### Child Component

```typescript
import { Component, Input } from "@angular/core";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-item",
  standalone: true,
  template: `
    <div class="task-item" [class.completed]="task.completed">
      <input type="checkbox" [checked]="task.completed" />
      <span>{{ task.title }}</span>
      <small>{{ task.createdAt | date : "short" }}</small>
    </div>
  `,
  styles: [
    `
      .task-item {
        padding: 1rem;
        border: 1px solid #ddd;
      }
      .completed {
        opacity: 0.5;
        text-decoration: line-through;
      }
    `,
  ],
})
export class TaskItemComponent {
  @Input() task!: Task;
}
```

### Parent Component

```typescript
import { Component } from "@angular/core";
import { CommonModule } from "@angular/common";
import { TaskItemComponent } from "./task-item/task-item.component";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-list",
  standalone: true,
  imports: [CommonModule, TaskItemComponent],
  template: `
    <div>
      @for (task of tasks; track task.id) {
      <app-task-item [task]="task"></app-task-item>
      }
    </div>
  `,
})
export class TaskListComponent {
  tasks: Task[] = [
    { id: 1, title: "Learn Angular", completed: false, createdAt: new Date() },
    { id: 2, title: "Build app", completed: true, createdAt: new Date() },
  ];
}
```

### Advanced @Input Features

#### Optional Input with Default

```typescript
@Component({...})
export class MyComponent {
  @Input() title = 'Default Title';
  @Input() count: number = 0;
}
```

#### Required Input

```typescript
import { Input } from '@angular/core';

@Component({...})
export class MyComponent {
  @Input({ required: true }) title!: string;
}
```

#### Input with Transform

```typescript
import { Input, booleanAttribute, numberAttribute } from '@angular/core';

@Component({...})
export class MyComponent {
  // Converts string '123' to number 123
  @Input({ transform: numberAttribute }) count = 0;

  // Converts various truthy strings to boolean
  @Input({ transform: booleanAttribute }) isActive = false;
}
```

#### Respond to Input Changes

```typescript
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({...})
export class MyComponent implements OnChanges {
  @Input() title = '';

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['title']) {
      console.log('Title changed to:', changes['title'].currentValue);
    }
  }
}
```

---

## 2. Child to Parent: @Output

Emit events from child to parent:

### Child Component

```typescript
import { Component, Output, EventEmitter } from "@angular/core";

@Component({
  selector: "app-task-form",
  standalone: true,
  template: `
    <form (ngSubmit)="onSubmit()">
      <input
        type="text"
        [(ngModel)]="title"
        name="title"
        placeholder="Enter task"
      />
      <button type="submit">Add Task</button>
    </form>
  `,
})
export class TaskFormComponent {
  title = "";

  // Define an output event
  @Output() taskAdded = new EventEmitter<string>();

  onSubmit(): void {
    if (this.title.trim()) {
      this.taskAdded.emit(this.title);
      this.title = "";
    }
  }
}
```

### Parent Component

```typescript
import { Component } from "@angular/core";
import { CommonModule } from "@angular/common";
import { TaskFormComponent } from "./task-form/task-form.component";
import { Task } from "../models/task.model";

@Component({
  selector: "app-task-manager",
  standalone: true,
  imports: [CommonModule, TaskFormComponent],
  template: `
    <div>
      <app-task-form (taskAdded)="onTaskAdded($event)"></app-task-form>

      <ul>
        @for (task of tasks; track task.id) {
        <li>{{ task.title }}</li>
        }
      </ul>
    </div>
  `,
})
export class TaskManagerComponent {
  tasks: Task[] = [];
  private nextId = 1;

  onTaskAdded(title: string): void {
    const newTask: Task = {
      id: this.nextId++,
      title,
      completed: false,
      createdAt: new Date(),
    };
    this.tasks.push(newTask);
  }
}
```

### Two-Way Communication with @Input and @Output

```typescript
// Child component
@Component({...})
export class ToggleComponent {
  @Input() isActive = false;
  @Output() isActiveChange = new EventEmitter<boolean>();

  toggle(): void {
    this.isActive = !this.isActive;
    this.isActiveChange.emit(this.isActive);
  }
}

// Parent component - using two-way binding
@Component({
  template: `
    <!-- Traditional way -->
    <app-toggle [isActive]="isOpen" (isActiveChange)="isOpen = $event"></app-toggle>

    <!-- Or with banana-in-a-box syntax -->
    <app-toggle [(isActive)]="isOpen"></app-toggle>
  `
})
export class ParentComponent {
  isOpen = false;
}
```

---

## 3. Sibling Communication: Shared Service

When siblings need to communicate, use a shared service:

### Service

```typescript
import { Injectable } from "@angular/core";
import { BehaviorSubject, Observable } from "rxjs";
import { Task } from "../models/task.model";

@Injectable({ providedIn: "root" })
export class TaskService {
  private taskSubject = new BehaviorSubject<Task[]>([]);
  tasks$ = this.taskSubject.asObservable();

  private selectedTaskSubject = new BehaviorSubject<Task | null>(null);
  selectedTask$ = this.selectedTaskSubject.asObservable();

  getTasks(): Observable<Task[]> {
    return this.tasks$;
  }

  setTasks(tasks: Task[]): void {
    this.taskSubject.next(tasks);
  }

  selectTask(task: Task): void {
    this.selectedTaskSubject.next(task);
  }

  getSelectedTask(): Observable<Task | null> {
    return this.selectedTask$;
  }
}
```

### First Child Component

```typescript
@Component({
  selector: "app-task-list",
  template: `
    <ul>
      @for (task of tasks(); track task.id) {
      <li (click)="selectTask(task)">{{ task.title }}</li>
      }
    </ul>
  `,
})
export class TaskListComponent {
  tasks = signal<Task[]>([]);

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    // Load tasks and update signal
    this.taskService.getTasks().subscribe((tasks) => {
      this.tasks.set(tasks);
    });
  }

  selectTask(task: Task): void {
    this.taskService.selectTask(task);
  }
}
```

### Second Child Component

```typescript
@Component({
  selector: "app-task-detail",
  template: `
    @if (selectedTask(); as task) {
    <div>
      <h3>{{ task.title }}</h3>
      <p>{{ task.description }}</p>
    </div>
    } @else {
    <p>Select a task to view details</p>
    }
  `,
})
export class TaskDetailComponent {
  selectedTask = signal<Task | null>(null);

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    this.taskService.getSelectedTask().subscribe((task) => {
      this.selectedTask.set(task);
    });
  }
}
```

---

## 4. Template Reference Variables

Reference child components directly in the template:

```typescript
// Child component
@Component({
  selector: "app-counter",
  standalone: true,
  template: `
    <p>Count: {{ count }}</p>
    <button (click)="increment()">+</button>
  `,
})
export class CounterComponent {
  count = 0;

  increment(): void {
    this.count++;
  }

  reset(): void {
    this.count = 0;
  }
}

// Parent component
@Component({
  selector: "app-parent",
  standalone: true,
  imports: [CounterComponent],
  template: `
    <div>
      <app-counter #counter></app-counter>
      <button (click)="resetCounter()">Reset from Parent</button>
    </div>
  `,
})
export class ParentComponent {
  @ViewChild("counter") counterComponent!: CounterComponent;

  resetCounter(): void {
    this.counterComponent.reset();
  }
}
```

---

## 5. Content Projection: ng-content

Allow parents to inject content into children:

### Child Component

```typescript
@Component({
  selector: "app-card",
  template: `
    <div class="card">
      <div class="card-header">
        <ng-content select="[cardHeader]"></ng-content>
      </div>
      <div class="card-body">
        <ng-content></ng-content>
      </div>
      <div class="card-footer">
        <ng-content select="[cardFooter]"></ng-content>
      </div>
    </div>
  `,
  styles: [
    `
      .card {
        border: 1px solid #ddd;
        border-radius: 4px;
      }
    `,
  ],
})
export class CardComponent {}
```

### Parent Component

```typescript
@Component({
  template: `
    <app-card>
      <h2 cardHeader>Task Details</h2>

      <p>This is the main content</p>

      <button cardFooter>Close</button>
    </app-card>
  `,
})
export class ParentComponent {}
```

---

## 6. Dependency Injection in Services

Services can inject other services:

```typescript
// Logger service
@Injectable({ providedIn: 'root' })
export class LoggerService {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }
}

// Task service uses logger
@Injectable({ providedIn: 'root' })
export class TaskService {
  constructor(private logger: LoggerService) {}

  createTask(title: string): void {
    this.logger.log(`Creating task: ${title}`);
    // Create task...
  }
}

// Component uses task service
@Component({...})
export class TaskFormComponent {
  constructor(private taskService: TaskService) {}
  // TaskService automatically gets LoggerService injected
}
```

---

## Communication Patterns Summary

| Pattern              | When to Use                             | Complexity |
| :------------------- | :-------------------------------------- | :--------- |
| **@Input**           | Pass data down to child                 | Low        |
| **@Output**          | Send events up to parent                | Low        |
| **Shared Service**   | Communicate between siblings or complex | Medium     |
| **@ViewChild**       | Access child component instance         | Medium     |
| **ng-content**       | Reusable templates with slots           | Medium     |
| **State Management** | Large apps with complex state           | High       |

---

## Best Practices

1. ✅ Keep components focused and single-responsibility
2. ✅ Use @Input/@Output for parent-child relationships
3. ✅ Use services for shared state across components
4. ✅ Avoid tight coupling between components
5. ✅ Use signals in services for reactive state management
6. ✅ Document @Input and @Output properties
7. ❌ Avoid accessing sibling components directly
8. ❌ Don't put too much logic in components

---

## Summary

- **@Input:** Pass data from parent to child
- **@Output:** Emit events from child to parent
- **Services:** Share state between components
- **@ViewChild:** Reference child component directly
- **ng-content:** Project content from parent to child
- **Signals:** Modern reactive state management
- **RxJS:** Observable-based async operations
