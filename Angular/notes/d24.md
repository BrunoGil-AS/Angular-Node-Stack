# Day 24: Simple State Management with Signals

**Overview:** In Angular there are 2 main modern approaches to state management:

1. Using Signals for local/shared state in small-to-medium apps.
2. Using state management libraries (NgRx, Akita, etc.) for large/complex apps.

## Key Concepts

- **Global state:** Shared state accessible across multiple components.
  - Auth data
  - Session data
  - Shopping cart
- **Local state:** Component-specific state.
  - Form data
  - Toggle

## Signal Store Pattern

As we already covered, Signals are reactive containers that notify automatically to consumers when the content has changed.

**Main Types of Signals:**

- `signal():` stores mutable state.
- `computed():` derives values from other signals.
- `effect():` executes logic when a signal changes.

```typescript
@Injectable({ providedIn: "root" })
export class TodoStore {
  private _todos = signal<Todo[]>([]);
  todos = this._todos.asReadonly();
  // effect to log changes
  constructor() {
    effect(() => {
      console.log("Todos changed:", this._todos());
    });
  }

  // Derived/computed signals
  completedCount = computed(
    () => this._todos().filter((t) => t.completed).length
  );

  add(todo: Todo) {
    this._todos.update((list) => [...list, todo]);
  }
  toggle(id: number) {
    this._todos.update((list) =>
      list.map((t) => (t.id === id ? { ...t, completed: !t.completed } : t))
    );
  }
  remove(id: number) {
    this._todos.update((list) => list.filter((t) => t.id !== id));
  }
}
```

> Components can inject `TodoStore` and read `store.todos()` or subscribe to `store.completedCount()`.
>
> Pros:
>
> - Simple, does not require **subscribe** and **unsubscribe**.
> - Native integration with forms and components
> - Ideal for local state and small apps.

---

## NgRx (Redux for Angular)

**What is NgRx?** is `a reactive state management library` for Angular applications, built on the principles of Redux. It helps developers manage complex application state in a predictable, scalable, and testable way by using a single global store, actions, reducers, and effects.

### **Key Concepts of NgRx:**

- **Store:** A centralized container holding the application‚Äôs state.
- **Actions:** Plain objects that describe events (e.g., loginUser, loadProducts).
- **Reducers:** Pure functions that take the current state and an action, then return a new state.
- **Selectors:** Functions that extract specific slices of state for components.
- **Effects:** Handle side effects like API calls, ensuring state updates remain pure.
- **Entity & Component Store:** Utilities for managing collections and local component state.

### ‚öôÔ∏è **How NgRx Works:**

1. Component dispatches an Action ‚Üí e.g., AddItem.
2. Reducer processes the Action ‚Üí updates the Store with new state.
3. Selectors notify Components ‚Üí components automatically re-render with updated data.
4. Effects handle async tasks ‚Üí e.g., fetching data from a server before updating the Store.

> This cycle ensures predictable state transitions and avoids spaghetti code where components manage their own isolated states

### üõ†Ô∏è **Setting Up NgRx with Signals:**

1. **Install NgRx Packages:**

   ```bash
   ng add @ngrx/store@latest @ngrx/effects@latest @ngrx/store-devtools@latest
   ```

2. **Define State:**

   ```typescript
   // todo.model.ts
   export interface Todo {
     id: number;
     title: string;
     completed: boolean;
   }

   export interface TodoState {
     todos: Todo[];
     loading: boolean;
   }
   ```

3. **Actions Definition:**

   ```typescript
   // todo.actions.ts
   import { createAction, props } from "@ngrx/store";
   import { Todo } from "./todo.model";

   export const loadTodos = createAction("[Todo] Load Todos");
   export const loadTodosSuccess = createAction(
     "[Todo] Load Todos Success",
     props<{ todos: Todo[] }>()
   );
   export const loadTodosFailure = createAction(
     "[Todo] Load Todos Failure",
     props<{ error: any }>()
   );

   export const addTodo = createAction(
     "[Todo] Add Todo",
     props<{ todo: Todo }>()
   );
   export const toggleTodo = createAction(
     "[Todo] Toggle Todo",
     props<{ id: number }>()
   );
   ```

4. **Create Reducers:**

   ```ts
   // todo.reducer.ts
   import { createReducer, on } from "@ngrx/store";
   import { TodoState } from "./todo.model";
   import * as TodoActions from "./todo.actions";

   export const initialState: TodoState = {
     todos: [],
     loading: false,
   };

   export const todoReducer = createReducer(
     initialState,
     on(TodoActions.loadTodos, (state) => ({ ...state, loading: true })),
     on(TodoActions.loadTodosSuccess, (state, { todos }) => ({
       ...state,
       todos,
       loading: false,
     })),
     on(TodoActions.loadTodosFailure, (state) => ({
       ...state,
       loading: false,
     })),
     on(TodoActions.addTodo, (state, { todo }) => ({
       ...state,
       todos: [...state.todos, todo],
     })),
     on(TodoActions.toggleTodo, (state, { id }) => ({
       ...state,
       todos: state.todos.map((t) =>
         t.id === id ? { ...t, completed: !t.completed } : t
       ),
     }))
   );
   ```

5. **Create Selectors:**

   ```ts
   // todo.selectors.ts
   import { createFeatureSelector, createSelector } from "@ngrx/store";
   import { TodoState } from "./todo.model";

   export const selectTodoState = createFeatureSelector<TodoState>("todos");

   export const selectAllTodos = createSelector(
     selectTodoState,
     (state) => state.todos
   );
   export const selectCompletedTodos = createSelector(selectAllTodos, (todos) =>
     todos.filter((t) => t.completed)
   );
   export const selectLoading = createSelector(
     selectTodoState,
     (state) => state.loading
   );
   ```

6. **Handle Side Effects:**

   ```ts
   // todo.effects.ts
   import { Injectable } from "@angular/core";
   import { Actions, createEffect, ofType } from "@ngrx/effects";
   import { of } from "rxjs";
   import { map, mergeMap, catchError } from "rxjs/operators";
   import * as TodoActions from "./todo.actions";
   import { TodoService } from "./todo.service";

   @Injectable()
   export class TodoEffects {
     constructor(private actions$: Actions, private todoService: TodoService) {}

     loadTodos$ = createEffect(() =>
       this.actions$.pipe(
         ofType(TodoActions.loadTodos),
         mergeMap(() =>
           this.todoService.getTodos().pipe(
             map((todos) => TodoActions.loadTodosSuccess({ todos })),
             catchError((error) => of(TodoActions.loadTodosFailure({ error })))
           )
         )
       )
     );
   }
   ```

7. **Use in a Component:**

   ```ts
   // todo.component.ts
   import { Component } from "@angular/core";
   import { Store } from "@ngrx/store";
   import { Observable } from "rxjs";
   import * as TodoActions from "./todo.actions";
   import * as TodoSelectors from "./todo.selectors";
   import { Todo } from "./todo.model";

   @Component({
     selector: "app-todo",
     template: `
       <div *ngIf="loading$ | async">Loading...</div>
       <ul>
         <li *ngFor="let todo of todos$ | async">
           <input
             type="checkbox"
             [checked]="todo.completed"
             (change)="toggle(todo.id)"
           />
           {{ todo.title }}
         </li>
       </ul>
       <button (click)="addTodo()">Add Todo</button>
     `,
   })
   export class TodoComponent {
     todos$: Observable<Todo[]> = this.store.select(
       TodoSelectors.selectAllTodos
     );
     loading$: Observable<boolean> = this.store.select(
       TodoSelectors.selectLoading
     );

     constructor(private store: Store) {
       this.store.dispatch(TodoActions.loadTodos());
     }

     addTodo() {
       const newTodo: Todo = {
         id: Date.now(),
         title: "New Task",
         completed: false,
       };
       this.store.dispatch(TodoActions.addTodo({ todo: newTodo }));
     }

     toggle(id: number) {
       this.store.dispatch(TodoActions.toggleTodo({ id }));
     }
   }
   ```

#### How Each Concept Fits Together

- **Actions** ‚Üí describe events (loadTodos, addTodo).
- **Reducer** ‚Üí updates state based on actions.
- **Selectors** ‚Üí extract slices of state for components.
- **Effects** ‚Üí handle async operations (API calls).
- **Store** ‚Üí central state container accessed by components.

### üîë Core Best Practices

1. **State Organization:**

   - Feature Stores: Split state into feature modules (books, auth, cart) instead of one giant store.
   - Minimal State: Store only what you need (no derived data, no UI flags unless shared).
   - Immutable Updates: Always return new objects in reducers; never mutate state.

2. **Actions:**

   - Descriptive Names: Use [Feature] Action format (e.g., [Auth] Login Success).
   - Action Groups: Use createActionGroup to keep related actions together.
   - Payloads: Keep payloads minimal and typed with props.

3. **Reducers:**

   - Pure Functions: Reducers must be deterministic‚Äîno API calls, no random values.
   - Switch with createReducer: Prefer on() handlers for clarity and type safety.
   - Initial State: Define explicit initial state for each feature.

4. **Selectors:**

   - Encapsulation: Expose selectors instead of accessing state directly.
   - Composition: Build complex selectors from smaller ones.
   - Memoization: Use createSelector to avoid unnecessary recomputation.

5. **Effects**

   - Side Effects Only: Handle async tasks (HTTP, localStorage) here, not in reducers.
   - Error Handling: Always catch errors and dispatch failure actions.
   - Single Responsibility: Keep effects small and focused.

6. **DevTools & Debugging:**

   - Enable Store DevTools: Use provideStoreDevtools with maxAge for time‚Äëtravel debugging.
   - Log Actions: Useful during development to trace flow.

7. **Testing:**

   - Reducer Tests: Verify state transitions for each action.
   - Effect Tests: Mock services and assert dispatched actions.
   - Selector Tests: Ensure correct slices of state are returned.
