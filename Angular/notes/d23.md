# Day 23: Forms - Template-Driven & Reactive

## Two Approaches

In Angular, there are two main approaches to handling forms:

1. Template-driven forms: Simple forms declared in template with `ngModel`. Best for small/simple forms.
2. Reactive forms: Programmatic, `FormControl`/`FormGroup`, better for complex validation and dynamic forms.

---

## Template-Driven Forms

```html
<!-- form.component.html -->
<form #f="ngForm" (ngSubmit)="onSubmit(f.value)">
  <input name="email" [(ngModel)]="email" required email />
  <button type="submit" [disabled]="f.invalid">Submit</button>
</form>
```

```ts
//form.component.ts
@Component({
  selector: "app-form",
  templateUrl: "./form.component.html",
})
export class FormComponent {
  email: string = "";

  onSubmit(value: any) {
    console.log(value);
  }
}
```

- Easy to use; validation via template directives.
- Less control for dynamic forms.

**standalone components**:

```typescript
import { Component, signal } from "@angular/core";
import { FormsModule } from "@angular/forms";
@Component({
  selector: "app-email-template",
  template: ` Email: <input type="text" [(ngModel)]="email" /> `,
  imports: [FormsModule],
})
export class EmailTemplate {
  email = signal("");
}
```

> As Standalone components gain more features, template-driven forms generate an automatic Form-Control tree behind the scenes.
>
> - This is the reason to use a signal for the model value instead of a simple property, in mail input

---

## Reactive Forms

**form-component/form.component.ts**:

```typescript
import { Component, OnInit } from "@angular/core";
import {
  FormBuilder,
  FormGroup,
  Validators,
  FormArray,
  FormControl,
} from "@angular/forms";
import { ReactiveFormsModule } from "@angular/forms";
import { CommonModule } from "@angular/common";

@Component({
  selector: "app-form",
  templateUrl: "./form.component.html",
  styleUrls: ["./form.component.css"],
  imports: [ReactiveFormsModule, CommonModule],
  standalone: true,
})
export class FormComponent implements OnInit {
  form!: FormGroup; // Define the form group ! to avoid TS error
  // Inject FormBuilder
  constructor(private fb: FormBuilder) {}

  ngOnInit() {
    // Initialize the form
    this.form = this.fb.group({
      // Define form controls
      name: ["", [Validators.required, Validators.minLength(3)]], // required name field with min length validator
      email: ["", [Validators.required, Validators.email]], // required email field with email format validator
      tags: this.fb.array([]), // dynamic array of tags
    });
  }

  get tags(): FormArray {
    return this.form.get("tags") as FormArray;
  }

  addTag() {
    this.tags.push(new FormControl("", Validators.required));
  }

  removeTag(index: number) {
    this.tags.removeAt(index);
  }

  submit() {
    if (this.form.valid) {
      console.log(this.form.value);
    }
  }
}
```

**form-component/form.component.html**:

```html
<form [formGroup]="form" (ngSubmit)="submit()">
  <!-- Name Field -->
  <div class="form-group">
    <label for="name">Name:</label>
    <input id="name" type="text" formControlName="name" />
    <div
      *ngIf="form.get('name')?.invalid && form.get('name')?.touched"
      class="error"
    >
      <!-- Show errors if invalid and touched -->
      <span *ngIf="form.get('name')?.errors?.['required']"
        >Name is required</span
      >
      <!-- Check for required error -->
      <span *ngIf="form.get('name')?.errors?.['minlength']"
        >Name must be at least 3 characters</span
      >
      <!-- Check for minlength error -->
    </div>
  </div>

  <!-- Email Field -->
  <div class="form-group">
    <label for="email">Email:</label>
    <input id="email" type="email" formControlName="email" />
    <div
      *ngIf="form.get('email')?.invalid && form.get('email')?.touched"
      class="error"
    >
      <span *ngIf="form.get('email')?.errors?.['required']"
        >Email is required</span
      >
      <span *ngIf="form.get('email')?.errors?.['email']"
        >Invalid email format</span
      >
    </div>
  </div>

  <!-- Tags Array -->
  <div formArrayName="tags">
    <div *ngFor="let tag of tags.controls; let i = index" class="tag-item">
      <input type="text" [formControlName]="i" placeholder="Enter tag" />
      <button type="button" (click)="removeTag(i)">Remove</button>
    </div>
  </div>
  <button type="button" (click)="addTag()">Add Tag</button>

  <!-- Submit Button -->
  <button type="submit" [disabled]="form.invalid">Save</button>
</form>
```

---

## Dynamic Forms

- Build form groups/arrays programmatically at runtime.
- Useful for variable-length lists and conditional controls.

---

## Custom Validators

```typescript
export function forbiddenName(name: RegExp): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const forbidden = name.test(control.value);
    return forbidden ? { forbiddenName: { value: control.value } } : null;
  };
}

this.form.get("name")?.setValidators([forbiddenName(/admin/)]);
```

Async validators return `Promise<ValidationErrors|null>` or `Observable<ValidationErrors|null>`.

---

## Value & Status Changes

- `control.valueChanges` and `control.statusChanges` are observables to react to changes.

```typescript
this.form.valueChanges.pipe(debounceTime(300)).subscribe((val) => {
  /* live validation/search */
});
```

---

## Form Performance

- Use `OnPush` change detection where possible.
- Avoid heavy logic in `valueChanges` subscriptions.

---

## Accessibility & UX

- Use `aria-*` attributes.
- Show clear error messages.
- Keep focus management on validation errors when submitting.

---

## Best Practices

- Use reactive forms for complex apps.
- Keep validation logic reusable (validators in separate files).
- Provide clear UX for errors and loading states.
- Test validators and edge cases.
