# Day 21: Routing & Navigation (SPA)

## Angular Router Basics

Routes map URL paths to components. Configure with `Routes` and provide via `provideRouter` or `RouterModule.forRoot()` in traditional modules.

```typescript
export const APP_ROUTES: Routes = [
  { path: "", redirectTo: "/home", pathMatch: "full" },
  { path: "home", component: HomeComponent },
  { path: "tasks", component: TaskListComponent },
  { path: "tasks/:id", component: TaskDetailComponent },
  { path: "**", component: NotFoundComponent },
];
```

### RouterLink and Navigation

- Template: `<a [routerLink]="['/tasks', task.id]">Open</a>`
- Programmatic: `this.router.navigate(['/tasks', id], { queryParams: { ref: 'email' } });`

---

## Route Parameters and Query Params

- `ActivatedRoute` provides `paramMap` and `queryParamMap`.
- Use `snapshot` for one-time read, observables for changes.

```typescript
this.route.paramMap.subscribe((params) => {
  const id = params.get("id");
});
```

---

## Child Routes & Layouts

Nested routes allow layouts with outlets:

```typescript
{ path: 'admin', component: AdminShell, children: [ { path: 'users', component: AdminUsers } ] }
```

---

## Lazy Loading

Split large apps into lazy-loaded modules for performance.

```typescript
{ path: 'shop', loadChildren: () => import('./shop/shop.routes').then(m => m.SHOP_ROUTES) }
```

Preloading strategies (PreloadAllModules) improve UX after initial load.

---

## Guards

- `CanActivate` — block navigation.
- `CanActivateChild` — guard child routes.
- `CanDeactivate` — prevent leaving a route.
- `Resolve` — fetch data before activating a route.

```typescript
@Injectable({ providedIn: "root" })
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}
  canActivate(): boolean | UrlTree {
    if (this.auth.isLoggedIn()) return true;
    return this.router.parseUrl("/login");
  }
}
```

---

## Navigation Extras

- `replaceUrl`, `skipLocationChange`, `state` are available for advanced scenarios.
- Use `router.getCurrentNavigation()?.extras.state` to read passed state.

---

## Resolvers

Resolvers let you load required data before the component is created to avoid loading states inside the component.

---

## Best Practices

- Keep routes declarative and small.
- Use lazy loading for feature areas.
- Use guards and resolvers to secure and prepare routes.
- Use route data (`data: { title: 'Tasks' }`) for meta info.
