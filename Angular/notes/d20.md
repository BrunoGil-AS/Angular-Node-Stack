# Day 20: Services & Dependency Injection (DI)

**creating a service:** You can create a service with angular cli.

    ```bash
    ng generate service CUSTOM_NAME
    ```

> This creates a dedicated **`CUSTOM_NAME.ts`** file in your **`src`** directory.

Also, by adding the `@Injectable()` decorator to a TypeScript class, you can also manually create a service.

```typescript
// ðŸ“„ src/app/basic-data-store.ts
import { Injectable } from "@angular/core";
@Injectable({ providedIn: "root" })
export class BasicDataStore {
  private data: string[] = [];
  addData(item: string): void {
    this.data.push(item);
  }
  getData(): string[] {
    return [...this.data];
  }
}
```

`providedIn` is an optional parameter that specifies where the service should be provided, this feature makes this injectable a singleton.

> This is a simple service that stores a list of strings and provides methods to add and retrieve data.
>
> As in any other framework, within the service you can add fields that can be injected in the constructor, have methods in the service as a representation of the business logic, and so on.

---

## Injecting a service

Once you've created a service as below you can inject it anywhere in your application using the `inject()` function from `@angular/core`.

```typescript
// ðŸ“„ src/app/example.component.ts
import { Component, inject } from "@angular/core";
import { BasicDataStore } from "./basic-data-store";
@Component({
  selector: "app-example",
  template: `
    <div>
      <p>{{ dataStore.getData() }}</p>
      <button (click)="dataStore.addData('More data')">Add more data</button>
    </div>
  `,
})
export class ExampleComponent {
  dataStore = inject(BasicDataStore);
}
```

> The example component uses the `inject()` function to get an instance of the `BasicDataStore` service.

But not only services are injectable to components, you can also inject them to other services.

```typescript
// ðŸ“„ src/app/advanced-data-store.ts
import { inject, Injectable } from "@angular/core";
import { BasicDataStore } from "./basic-data-store";
@Injectable({
  providedIn: "root",
})
export class AdvancedDataStore {
  private basicDataStore = inject(BasicDataStore);
  private data: string[] = [];
  addData(item: string): void {
    this.data.push(item);
  }
  getData(): string[] {
    return [...this.data, ...this.basicDataStore.getData()];
  }
}
```

---

## Sharing Data: Storing a signal inside a service

You can use a service to hold a `signal` and share its state between unrelated components. This is a powerful pattern for state management.

Let's imagine the following project structure:

```
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ component-a/
â”‚   â”‚   â”‚   â””â”€â”€ component-a.component.ts
â”‚   â”‚   â””â”€â”€ component-b/
â”‚   â”‚       â””â”€â”€ component-b.component.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ counter.service.ts
â”‚   â””â”€â”€ app.component.ts
â””â”€â”€ ...
```

Here's how you could implement the `CounterService` and use it in `ComponentA` and `ComponentB`.

**The Service with the Signal**

The service holds the signal and methods to modify it.

```typescript
// ðŸ“„ src/app/services/counter.service.ts
import { Injectable, signal } from "@angular/core";

@Injectable({
  providedIn: "root",
})
export class CounterService {
  public count = signal(0);

  increment() {
    this.count.update((c) => c + 1);
  }

  decrement() {
    this.count.update((c) => c - 1);
  }
}
```

**The Components**

Both components inject the `CounterService` and can both read the `count` signal and call the methods to change its value. Because they share the same service instance (due to `providedIn: 'root'`), they will always see the same state.

```typescript
// ðŸ“„ src/app/components/component-a/component-a.component.ts
import { Component, inject } from "@angular/core";
import { CounterService } from "../../services/counter.service";

@Component({
  selector: "app-component-a",
  template: `
    <h2>Component A</h2>
    <p>Current Count: {{ counterService.count() }}</p>
    <button (click)="counterService.increment()">Increment</button>
  `,
})
export class ComponentA {
  counterService = inject(CounterService);
}
```

```typescript
// ðŸ“„ src/app/components/component-b/component-b.component.ts
import { Component, inject } from "@angular/core";
import { CounterService } from "../../services/counter.service";

@Component({
  selector: "app-component-b",
  template: `
    <h2>Component B</h2>
    <p>Current Count: {{ counterService.count() }}</p>
    <button (click)="counterService.decrement()">Decrement</button>
  `,
})
export class ComponentB {
  counterService = inject(CounterService);
}
```

When the button in `ComponentA` is clicked, the count is incremented. `ComponentB` will automatically reflect this change because it's reading the same signal from the shared `CounterService`.

## Summary

Services in Angular are a key feature for code reusability and modularity. They are typically singleton classes decorated with `@Injectable({ providedIn: 'root' })` that can be injected into components or other services. Services are used to share data and business logic across different parts of the application. A common pattern is to use a service to hold state, for example using signals, and allow multiple components to interact with that shared state.

## Exercise

To avoid generate more recicle code, I decided to continue the exercise of today in code of day passed (day 19), [here is the code](../Code/d19-in-output/src/app/services/cart/cart-service.ts).
