# Day 20: Services & Dependency Injection (DI)

## What is a Service?

A service is a reusable class that encapsulates business logic, data access, or utilities and is shared across components.

### Why use services?

- Single Responsibility: Keep components thin.
- Reuse: Share logic across many components.
- Testability: Easier to unit-test services.
- State: Hold shared state (with caution).

---

## Dependency Injection (DI)

DI is a pattern where a class receives its dependencies from the outside instead of creating them.

### Providers

- `providedIn: 'root'` — application-wide singleton.
- `providedIn: 'platform'` — shared across Angular platforms.
- `providedIn: SomeModule` — limited scope to a module.
- `providers: []` in component — creates a new instance per component subtree.

### Injection tokens

Use `InjectionToken<T>` for non-class dependencies (strings, config objects).

```typescript
export const API_URL = new InjectionToken<string>('API_URL');

{ provide: API_URL, useValue: 'https://api.example.com' }
```

### Provider types

- `useClass`: provide an alternative class.
- `useExisting`: alias to another token.
- `useValue`: static value.
- `useFactory`: function that returns a value (can inject other deps).

---

## Example Service

```typescript
@Injectable({ providedIn: "root" })
export class UserService {
  constructor(
    private http: HttpClient,
    @Inject(API_URL) private apiUrl: string
  ) {}

  getUsers() {
    return this.http.get<User[]>(`${this.apiUrl}/users`);
  }
}
```

---

## Interceptors

HTTP interceptors are services that implement `HttpInterceptor` to modify requests/responses.

```typescript
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    const token = localStorage.getItem('token');
    const authReq = token ? req.clone({ setHeaders: { Authorization: `Bearer ${token}` } }) : req;
    return next.handle(authReq);
  }
}

// Provide in app config
{ provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
```

---

## Hierarchical Injectors

Components can provide services in their `providers` array to create subtree-scoped instances. This allows different parts of the app to get different instances of the same service.

---

## Best Practices

- Prefer `providedIn: 'root'` for stateless services.
- Use tokens for configuration and non-class values.
- Keep services focused (one responsibility).
- Avoid storing large mutable state in services unless you manage updates (signals/observables).
- Use interceptors for cross-cutting HTTP concerns (auth, logging, error handling).
